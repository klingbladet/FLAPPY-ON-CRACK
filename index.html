<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy All-Stars: Kim K Fixed</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            height: 100%;
            max-height: 800px;
            background-color: #70c5ce;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
            border: 2px solid #444;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        /* HUD */
        #score-display {
            position: absolute;
            top: 10%;
            font-size: 3rem;
            color: white;
            text-shadow: 3px 3px 0 #000;
            z-index: 10;
        }

        #lives-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5rem;
            color: #ff4444;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
            text-align: left;
        }

        #knife-display {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.2rem;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
            text-align: right;
        }

        /* --- UI STYLES (Glows Removed) --- */
        #start-screen,
        #game-over-screen {
            background: rgba(20, 20, 20, 0.5);
            backdrop-filter: blur(8px);
            padding: 2rem;
            border-radius: 16px;
            pointer-events: auto;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.15);
            width: 90%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            color: #f4ce42;
            text-shadow: 3px 3px 0 #000;
            line-height: 1.4;
            white-space: nowrap;
        }

        p {
            font-size: 0.6rem;
            margin-bottom: 0.5rem;
            line-height: 1.6;
            color: #ccc;
        }

        input[type="text"] {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #555;
            color: #fff;
            padding: 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            width: 100%;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            border-radius: 8px;
            outline: none;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            border-color: #f4ce42;
        }

        /* Buttons */
        .btn {
            background: linear-gradient(135deg, #e06018, #d35400);
            border: none;
            color: white;
            padding: 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #a04000;
            border-radius: 8px;
            transition: all 0.1s;
            margin-top: 15px;
            width: 100%;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #a04000;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #555, #333);
            box-shadow: 0 4px 0 #222;
        }

        .btn-secondary:active {
            box-shadow: 0 0 0 #222;
        }

        /* Option Grid */
        .selector-label {
            margin-top: 15px;
            color: #aaa;
            text-transform: uppercase;
            font-size: 0.6rem;
            text-align: left;
            letter-spacing: 1px;
        }

        .option-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 5px;
        }

        .opt-btn {
            padding: 10px 2px;
            font-size: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            color: #aaa;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .opt-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .opt-btn.selected {
            background: #73bf2e;
            color: #fff;
            border: 2px solid #fff;
            transform: scale(1.05);
        }

        /* Specific colors for selected state */
        .opt-btn[data-char="naruto"].selected {
            background: #F39C12;
        }

        .opt-btn[data-theme="leaf"].selected {
            background: #58D68D;
            color: #000;
        }

        .opt-btn[data-char="cartman"].selected {
            background: #E74C3C;
        }

        .opt-btn[data-char="killua"].selected {
            background: #95A5A6;
        }

        .opt-btn[data-char="stalin"].selected {
            background: #6E2C00;
        }

        .opt-btn[data-char="mussolini"].selected {
            background: #212F3C;
        }

        .opt-btn[data-char="kimj"].selected {
            background: #333;
        }

        .opt-btn[data-char="kimk"].selected {
            background: #FF69B4;
        }

        .opt-btn[data-theme="soviet"].selected {
            background: #C0392B;
        }

        .opt-btn[data-theme="southpark"].selected {
            background: #AED6F1;
            color: #000;
        }

        .leaderboard-container {
            margin-top: 20px;
            width: 100%;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 15px;
        }

        table {
            width: 100%;
            font-size: 0.65rem;
            color: #ccc;
            border-collapse: collapse;
        }

        th,
        td {
            padding: 8px 0;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        td:last-child {
            text-align: right;
            color: #f4ce42;
        }

        /* --- FIRE BUTTON (LEFT SIDE) --- */
        #fire-btn {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 80px;
            height: 80px;
            background: rgba(231, 76, 60, 0.8);
            border: 4px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            color: white;
            z-index: 20;
            user-select: none;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
            backdrop-filter: blur(4px);
        }

        #fire-btn:active {
            transform: scale(0.95);
            background: rgba(231, 76, 60, 1);
        }

        @media (min-width: 1024px) {
            #fire-btn {
                display: none;
            }
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="score-display">0</div>
        <div id="lives-display">‚ù§Ô∏è</div>
        <div id="knife-display">üî™ 0</div>

        <div id="fire-btn">‚öîÔ∏è</div>

        <div id="ui-layer">
            <div id="start-screen">
                <h1>FLAPPY ALL-STARS</h1>
                <input type="text" id="username-input" placeholder="ENTER NAME" maxlength="8">

                <p class="selector-label">Theme</p>
                <div class="option-grid" id="theme-selector">
                    <button class="opt-btn" data-theme="soviet">SOVIET</button>
                    <button class="opt-btn selected" data-theme="leaf">LEAF</button>
                    <button class="opt-btn" data-theme="southpark">S. PARK</button>
                </div>

                <p class="selector-label">Character</p>
                <div class="option-grid" id="char-selector">
                    <button class="opt-btn" data-char="cartman">CARTMAN</button>
                    <button class="opt-btn selected" data-char="naruto">NARUTO</button>
                    <button class="opt-btn" data-char="killua">KILLUA</button>
                    <button class="opt-btn" data-char="stalin">STALIN</button>
                    <button class="opt-btn" data-char="mussolini">MUSSOLINI</button>
                    <button class="opt-btn" data-char="kimj">KIM J</button>
                    <button class="opt-btn" data-char="kimk">KIM K</button>
                </div>

                <p class="selector-label">Difficulty</p>
                <div class="option-grid" id="diff-selector">
                    <button class="opt-btn" data-diff="easy">EASY</button>
                    <button class="opt-btn selected" data-diff="normal">NORMAL</button>
                    <button class="opt-btn" data-diff="hard">HARD</button>
                </div>

                <button id="start-btn" class="btn">START GAME</button>
                <p style="margin-top:15px; font-size: 0.55rem; color: #888; letter-spacing: 0.5px;">*Shift/Right-Click
                    to shoot (PC)*<br>*Button to shoot (Mobile)*</p>
            </div>

            <div id="game-over-screen" class="hidden">
                <h1>GAME OVER</h1>
                <p>Score: <span id="final-score">0</span></p>
                <div class="leaderboard-container">
                    <p>LEADERBOARD</p>
                    <table id="leaderboard-table"></table>
                </div>
                <button id="restart-btn" class="btn">TRY AGAIN</button>
                <button id="menu-btn" class="btn btn-secondary">CHANGE SETTINGS</button>
            </div>
        </div>
    </div>

    <script>

        const MUSIC_FILES = {
            soviet: 'audio/soviet-theme.mp3',
            leaf: 'audio/naruto-theme.mp3',
            southpark: 'audio/south-park-theme.mp3'
        };

        const DIFFICULTIES = {
            easy: { speed: 2.5, pipeInterval: 2200, gap: 150, enemyChance: 0 },
            normal: { speed: 3, pipeInterval: 1700, gap: 170, enemyChance: 0.002 },
            hard: { speed: 4, pipeInterval: 1400, gap: 150, enemyChance: 0.005 }
        };

        const THEMES = {
            soviet: { bgSky: '#5D6D7E', bgGround: '#2C3E50', pipeMain: '#5D6D7E', pipeStroke: '#17202A', clouds: false, factories: true, mountains: false, lifeIcon: '‚≠ê' },
            leaf: { bgSky: '#85C1E9', bgGround: '#58D68D', pipeMain: '#A04000', pipeStroke: '#6E2C00', clouds: true, factories: false, mountains: false, lifeIcon: 'üçú' },
            southpark: { bgSky: '#AED6F1', bgGround: '#FBFCFC', pipeMain: '#2ECC71', pipeStroke: '#27AE60', clouds: true, factories: false, mountains: true, lifeIcon: 'üßÄ' }
        };

        const CHARACTERS = {
            cartman: { color: '#E74C3C', hat: '#3498DB', face: '#F5CBA7' },
            naruto: { color: '#F39C12', hair: '#F1C40F', face: '#F5CBA7' },
            killua: { color: '#34495E', hair: '#ECF0F1', face: '#FDFEFE' },
            stalin: { color: '#6E2C00', uniform: '#D4AC0D', face: '#F5CBA7' },
            mussolini: { color: '#212F3C', uniform: '#212F3C', face: '#F5CBA7' },
            kimj: { color: '#2C3E50', suit: '#2C3E50', face: '#F5CBA7' },
            // Kim K: Silver Shirt, Tan Skin, Black Hair
            kimk: { color: '#C0C0C0', hair: '#000000', face: '#E0AC69' }
        };

        class Entity {
            constructor(x, y, width, height, color) {
                this.x = x; this.y = y; this.width = width; this.height = height; this.color = color; this.markedForDeletion = false;
            }
            update() { }
            draw(ctx) { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); }
            collidesWith(other) {
                const padding = 4;
                return (this.x + padding < other.x + other.width - padding && this.x + this.width - padding > other.x + padding && this.y + padding < other.y + other.height - padding && this.y + this.height - padding > other.y + padding);
            }
        }

        class Projectile extends Entity {
            constructor(x, y, targetX, targetY, theme) {
                super(x, y, 15, 15, '#fff');
                this.theme = theme;
                this.speed = 10;
                const dx = targetX - x; const dy = targetY - y; const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 0) { this.vx = (dx / dist) * this.speed; this.vy = (dy / dist) * this.speed; } else { this.vx = this.speed; this.vy = 0; }
                this.rotation = Math.atan2(this.vy, this.vx);
                this.spinAngle = 0;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.rotation += 0.2; this.spinAngle += 0.5;
                if (this.x < 0 || this.x > 2000 || this.y < 0 || this.y > 2000) this.markedForDeletion = true;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.spinAngle);
                if (this.theme === 'soviet') {
                    ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, 8, 0.5, Math.PI * 1.5); ctx.stroke(); ctx.fillStyle = '#FFD700'; ctx.fillRect(-2, 0, 4, 10);
                } else if (this.theme === 'leaf') {
                    ctx.fillStyle = '#2C3E50'; ctx.beginPath(); for (let i = 0; i < 4; i++) { ctx.rotate(Math.PI / 2); ctx.moveTo(0, 0); ctx.lineTo(8, 4); ctx.lineTo(0, 12); ctx.lineTo(-8, 4); } ctx.fill(); ctx.fillStyle = '#EEE'; ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.fillStyle = '#D6EAF8'; ctx.beginPath(); for (let i = 0; i < 4; i++) { ctx.rotate(Math.PI / 2); ctx.moveTo(0, 0); ctx.lineTo(4, 10); ctx.lineTo(-4, 10); } ctx.fill();
                }
                ctx.restore();
            }
        }

        class EnemyProjectile extends Entity {
            constructor(x, y) {
                super(x, y, 12, 12, '#e74c3c');
                this.speed = 6;
                this.vx = -this.speed;
            }
            update() {
                this.x += this.vx;
                if (this.x < 0) this.markedForDeletion = true;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
                ctx.restore();
            }
        }

        class Enemy extends Entity {
            constructor(x, y, theme, type) {
                const width = type === 'big' ? 80 : 40;
                const height = type === 'big' ? 80 : 40;
                super(x, y, width, height, '#000');
                this.theme = theme;
                this.type = type;
                this.vx = (type === 'big') ? 1.5 : (Math.random() * 2 + 1);
                this.wobble = Math.random() * Math.PI * 2;
                this.health = (type === 'big') ? 3 : 1;
                this.hitFlash = 0;
                this.shootTimer = Math.floor(Math.random() * 100) + 50;
            }

            update() {
                this.x -= this.vx;
                this.wobble += 0.1;
                this.y += Math.sin(this.wobble) * 2;
                if (this.hitFlash > 0) this.hitFlash--;

                if (this.type === 'shooter') {
                    this.shootTimer--;
                    if (this.shootTimer <= 0) {
                        this.shootTimer = 120;
                        return 'shoot';
                    }
                }

                if (this.x + this.width < 0) this.markedForDeletion = true;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                if (this.hitFlash > 0) {
                    ctx.globalCompositeOperation = 'source-atop';
                    ctx.fillStyle = 'white';
                }

                if (this.type === 'big') {
                    ctx.scale(2, 2);
                }

                if (this.type === 'shooter') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'red';
                }

                if (this.theme === 'soviet') {
                    ctx.fillStyle = '#000'; ctx.fillRect(-15, 0, 30, 20);
                    ctx.fillStyle = '#F5CBA7'; ctx.beginPath(); ctx.arc(0, -5, 15, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#17202A'; ctx.fillRect(-15, -25, 30, 15); ctx.fillRect(-20, -10, 40, 5);
                    ctx.strokeStyle = (this.type === 'shooter') ? 'red' : '#F1C40F';
                    ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(5, -5, 5, 0, Math.PI * 2); ctx.stroke();
                } else if (this.theme === 'leaf') {
                    ctx.fillStyle = '#212F3C'; ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#F5CBA7'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = (this.type === 'shooter') ? '#922B21' : '#17202A';
                    ctx.fillRect(-10, 2, 20, 10);
                    ctx.fillStyle = '#7F8C8D'; ctx.fillRect(-12, -12, 24, 6);
                    ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.moveTo(-5, -12); ctx.lineTo(5, -6); ctx.stroke();
                } else {
                    ctx.fillStyle = '#D7DBDD'; ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = '#F5CBA7'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = (this.type === 'shooter') ? 'red' : '#000';
                    ctx.beginPath(); ctx.arc(-4, 0, 2, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(4, 0, 2, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            }
        }

        class PowerUp extends Entity {
            constructor(x, y, type, theme) {
                super(x, y, 35, 35, type === 'life' ? 'red' : 'gold');
                this.type = type; this.theme = theme; this.initialY = y; this.angle = 0;
            }
            update(speed) {
                this.x -= speed; this.angle += 0.1; this.y = this.initialY + Math.sin(this.angle) * 20;
                if (this.x + this.width < 0) this.markedForDeletion = true;
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                if (this.theme === 'soviet') {
                    if (this.type === 'life') this.drawStar(ctx, 0, 0, 5, 15, 7, '#E74C3C', '#C0392B');
                    else { ctx.rotate(Math.sin(this.angle)); ctx.fillStyle = '#F1C40F'; ctx.fillRect(-4, -10, 8, 20); ctx.fillRect(-10, -12, 20, 8); }
                } else if (this.theme === 'leaf') {
                    if (this.type === 'life') { ctx.fillStyle = '#E59866'; ctx.beginPath(); ctx.arc(0, 5, 15, 0, Math.PI); ctx.fill(); ctx.fillStyle = '#F7DC6F'; ctx.beginPath(); ctx.ellipse(0, 5, 14, 4, 0, 0, Math.PI * 2); ctx.fill(); }
                    else { ctx.rotate(this.angle * 2); ctx.fillStyle = '#5D6D7E'; ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(4, -4); ctx.lineTo(15, 0); ctx.lineTo(4, 4); ctx.lineTo(0, 15); ctx.lineTo(-4, 4); ctx.lineTo(-15, 0); ctx.lineTo(-4, -4); ctx.fill(); }
                } else if (this.theme === 'southpark') {
                    if (this.type === 'life') { ctx.fillStyle = '#FF7F50'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#C0392B'; for (let i = 0; i < 5; i++) { ctx.beginPath(); ctx.arc(Math.random() * 20 - 10, Math.random() * 20 - 10, 2, 0, Math.PI * 2); ctx.fill(); } }
                    else { ctx.rotate(this.angle); ctx.strokeStyle = '#fff'; ctx.lineWidth = 3; for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(0, 15); ctx.stroke(); ctx.rotate(Math.PI / 3); } }
                }
                ctx.restore();
            }
            drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, fill, stroke) {
                let rot = Math.PI / 2 * 3; let x = cx, y = cy, step = Math.PI / spikes; ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius); for (let i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step; } ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.lineWidth = 2; ctx.strokeStyle = stroke; ctx.stroke(); ctx.fillStyle = fill; ctx.fill();
            }
        }

        class Character extends Entity {
            constructor(gameHeight, type = 'cartman') {
                super(50, gameHeight / 2, 40, 40, CHARACTERS[type].color);
                this.type = type; this.velocity = 0; this.gravity = 0.5; this.jumpStrength = -8; this.rotation = 0; this.gameHeight = gameHeight; this.invincible = false; this.invincibleTimer = 0; this.hue = 0;
            }
            flap() { this.velocity = this.jumpStrength; }
            activateStar() { this.invincible = true; this.invincibleTimer = 180; }
            update() {
                this.velocity += this.gravity; this.y += this.velocity;
                if (this.velocity < 0) this.rotation = -25 * (Math.PI / 180);
                else { this.rotation += 2 * (Math.PI / 180); if (this.rotation > 90 * (Math.PI / 180)) this.rotation = 90 * (Math.PI / 180); }
                if (this.invincible) { this.invincibleTimer--; this.hue += 10; if (this.invincibleTimer <= 0) this.invincible = false; }
                if (this.y + this.height > this.gameHeight - 50) { this.y = this.gameHeight - 50 - this.height; return 'ground'; }
                if (this.y < 0) { this.y = 0; this.velocity = 0; }
                return false;
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.rotation);
                let config = CHARACTERS[this.type];
                if (this.invincible) { ctx.shadowBlur = 15; ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`; }
                this.drawSpecificCharacter(ctx, config); ctx.restore();
            }
            drawSpecificCharacter(ctx, config) {
                ctx.fillStyle = config.face;
                if (this.type === 'cartman') { ctx.fillStyle = config.color; ctx.beginPath(); ctx.arc(0, 10, 22, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = config.face; ctx.beginPath(); ctx.arc(0, -5, 18, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(0, 5, 10, 0, Math.PI); ctx.stroke(); ctx.fillStyle = config.hat; ctx.beginPath(); ctx.arc(0, -10, 19, Math.PI, 0); ctx.fill(); ctx.fillStyle = '#F1C40F'; ctx.beginPath(); ctx.ellipse(0, -28, 5, 3, 0, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.moveTo(-18, -10); ctx.lineTo(18, -10); ctx.stroke(); }
                else if (this.type === 'naruto') { ctx.fillStyle = config.color; ctx.fillRect(-15, 10, 30, 20); ctx.fillStyle = config.face; ctx.beginPath(); ctx.arc(0, -5, 16, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = config.hair; ctx.beginPath(); for (let i = 0; i < 7; i++) { ctx.lineTo(-20 + (i * 6), -30 + (Math.random() * 10)); ctx.lineTo(-17 + (i * 6), -15); } ctx.fill(); ctx.fillStyle = '#2C3E50'; ctx.fillRect(-16, -18, 32, 6); ctx.fillStyle = '#95A5A6'; ctx.fillRect(-8, -17, 16, 4); ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.moveTo(-12, -2); ctx.lineTo(-6, -1); ctx.moveTo(-12, 1); ctx.lineTo(-6, 2); ctx.moveTo(-12, 4); ctx.lineTo(-6, 5); ctx.moveTo(12, -2); ctx.lineTo(6, -1); ctx.moveTo(12, 1); ctx.lineTo(6, 2); ctx.moveTo(12, 4); ctx.lineTo(6, 5); ctx.stroke(); }
                else if (this.type === 'killua') { ctx.fillStyle = config.color; ctx.fillRect(-15, 10, 30, 20); ctx.fillStyle = config.face; ctx.beginPath(); ctx.arc(0, -5, 15, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = config.hair; ctx.beginPath(); ctx.moveTo(-20, -10); ctx.lineTo(-25, -25); ctx.lineTo(-10, -15); ctx.lineTo(0, -30); ctx.lineTo(10, -15); ctx.lineTo(25, -25); ctx.lineTo(20, -10); ctx.fill(); ctx.fillStyle = '#2E86C1'; ctx.beginPath(); ctx.ellipse(-6, -2, 4, 2, 0.2, 0, Math.PI * 2); ctx.ellipse(6, -2, 4, 2, -0.2, 0, Math.PI * 2); ctx.fill(); }
                else if (this.type === 'stalin') { ctx.fillStyle = config.color; ctx.fillRect(-18, 8, 36, 22); ctx.fillStyle = config.face; ctx.fillRect(-15, -20, 30, 30); ctx.fillStyle = '#212121'; ctx.beginPath(); ctx.moveTo(-15, -15); ctx.quadraticCurveTo(0, -25, 15, -15); ctx.lineTo(15, -22); ctx.quadraticCurveTo(0, -32, -15, -22); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.moveTo(-10, 5); ctx.quadraticCurveTo(0, 0, 10, 5); ctx.quadraticCurveTo(12, 8, 8, 8); ctx.quadraticCurveTo(0, 5, -8, 8); ctx.quadraticCurveTo(-12, 8, -10, 5); ctx.fill(); }
                else if (this.type === 'mussolini') { ctx.fillStyle = config.color; ctx.fillRect(-18, 8, 36, 22); ctx.fillStyle = config.face; ctx.beginPath(); ctx.ellipse(0, -8, 16, 18, 0, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = '#D68910'; ctx.beginPath(); ctx.arc(0, 8, 5, 0, Math.PI); ctx.stroke(); }
                else if (this.type === 'kimj') { ctx.fillStyle = config.suit; ctx.fillRect(-18, 8, 36, 22); ctx.fillStyle = config.face; ctx.beginPath(); ctx.arc(0, -5, 18, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#000'; ctx.fillRect(-18, -25, 36, 10); ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(-12, -5); ctx.lineTo(-2, -5); ctx.moveTo(2, -5); ctx.lineTo(12, -5); ctx.stroke(); }
                else if (this.type === 'kimk') {
                    // Body (Silver shirt)
                    ctx.fillStyle = config.color; ctx.fillRect(-15, 10, 30, 20);
                    // Hair (DRAW FIRST so it's behind the face)
                    ctx.fillStyle = config.hair; ctx.beginPath(); ctx.moveTo(-16, -15); ctx.quadraticCurveTo(0, -25, 16, -15); ctx.lineTo(18, 15); ctx.lineTo(-18, 15); ctx.fill();
                    // Face (DRAW SECOND so it sits on top of the hair)
                    ctx.fillStyle = config.face; ctx.beginPath(); ctx.arc(0, -5, 16, 0, Math.PI * 2); ctx.fill();
                    // Sunglasses
                    ctx.fillStyle = '#111'; ctx.fillRect(-14, -8, 12, 6); ctx.fillRect(2, -8, 12, 6); ctx.fillRect(-2, -7, 4, 2);
                }

                if (this.type !== 'killua' && this.type !== 'kimk') { ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-6, -5, 4, 0, Math.PI * 2); ctx.arc(6, -5, 4, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-5, -5, 2, 0, Math.PI * 2); ctx.arc(7, -5, 2, 0, Math.PI * 2); ctx.fill(); }
            }
        }

        class Pipe extends Entity {
            constructor(x, y, width, height, type, theme) {
                super(x, y, width, height, '#73bf2e');
                this.type = type; this.theme = theme; this.passed = false; this.mainColor = THEMES[theme].pipeMain; this.strokeColor = THEMES[theme].pipeStroke;
            }
            update(speed) { this.x -= speed; if (this.x + this.width < 0) this.markedForDeletion = true; }
            draw(ctx) {
                ctx.fillStyle = this.mainColor; ctx.strokeStyle = this.strokeColor; ctx.lineWidth = 2; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height);
                const capHeight = 20; const capExtension = 4; let capY = this.type === 'top' ? this.y + this.height - capHeight : this.y;
                ctx.fillRect(this.x - capExtension, capY, this.width + (capExtension * 2), capHeight); ctx.strokeRect(this.x - capExtension, capY, this.width + (capExtension * 2), capHeight);
                ctx.globalAlpha = 0.2; ctx.fillStyle = '#000';
                if (this.theme === 'leaf') { ctx.beginPath(); ctx.arc(this.x + 30, this.y + 30, 10, 0, Math.PI * 2); ctx.fill(); }
                else if (this.theme === 'soviet') { ctx.fillRect(this.x + 5, capY + 5, 4, 4); ctx.fillRect(this.x + this.width - 9, capY + 5, 4, 4); }
                ctx.globalAlpha = 1.0;
            }
        }

        class Background {
            constructor(width, height) { this.width = width; this.height = height; this.cloudOffset = 0; this.groundOffset = 0; }
            update(speed) { this.cloudOffset -= speed * 0.2; if (this.cloudOffset <= -this.width) this.cloudOffset = 0; this.groundOffset -= speed; if (this.groundOffset <= -20) this.groundOffset = 0; }
            draw(ctx, themeName) {
                const theme = THEMES[themeName]; ctx.fillStyle = theme.bgSky; ctx.fillRect(0, 0, this.width, this.height);
                this.drawDecorations(ctx, themeName);
                if (theme.clouds) { ctx.fillStyle = 'rgba(255, 255, 255, 0.6)'; for (let i = 0; i < 5; i++) { let xPos = (i * 200 + this.cloudOffset) % (this.width + 200); if (xPos < -100) xPos += this.width + 200; this.drawCloud(ctx, xPos, 100 + (i % 2) * 50); } }
                if (theme.mountains) { ctx.fillStyle = '#ECF0F1'; for (let i = 0; i < 5; i++) { let x = (i * 150 + this.cloudOffset * 0.5) % (this.width + 300); if (x < -150) x += this.width + 300; ctx.beginPath(); ctx.moveTo(x, this.height - 50); ctx.lineTo(x + 100, this.height - 250); ctx.lineTo(x + 200, this.height - 50); ctx.fill(); } }
                if (theme.factories) { ctx.fillStyle = '#2C3E50'; for (let i = 0; i < 6; i++) { let x = (i * 120 + this.cloudOffset * 0.5) % (this.width + 120); if (x < -100) x += this.width + 120; ctx.fillRect(x, this.height - 150 - (i % 2) * 30, 60, 200); ctx.fillStyle = '#F4D03F'; ctx.fillRect(x + 10, this.height - 120, 10, 10); ctx.fillStyle = '#2C3E50'; } }
                ctx.fillStyle = theme.bgGround; ctx.fillRect(0, this.height - 50, this.width, 50); ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(0, this.height - 50, this.width, 5); ctx.fillStyle = 'rgba(0,0,0,0.1)'; for (let i = 0; i < this.width + 20; i += 20) { ctx.beginPath(); ctx.moveTo(i + this.groundOffset, this.height - 50); ctx.lineTo(i + this.groundOffset - 15, this.height); ctx.lineTo(i + this.groundOffset - 10, this.height); ctx.lineTo(i + this.groundOffset + 5, this.height - 50); ctx.fill(); }
            }
            drawDecorations(ctx, theme) {
                ctx.save(); ctx.globalAlpha = 0.4;
                for (let i = 0; i < 6; i++) {
                    let x = (i * 250 + this.cloudOffset * 0.8) % (this.width + 250); if (x < -100) x += this.width + 250; let y = 100 + (i * 50) % 300;
                    ctx.translate(x, y); ctx.rotate(this.cloudOffset * 0.01 + i);
                    if (theme === 'soviet') { ctx.strokeStyle = '#922B21'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(0, 0, 20, 0.5, Math.PI * 1.5); ctx.stroke(); ctx.fillStyle = '#922B21'; ctx.fillRect(-5, 0, 8, 20); }
                    else if (theme === 'leaf') { ctx.fillStyle = '#34495E'; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(8, 0); ctx.lineTo(0, 20); ctx.lineTo(-8, 0); ctx.fill(); }
                    else if (theme === 'southpark') { ctx.strokeStyle = '#D6EAF8'; ctx.lineWidth = 4; for (let j = 0; j < 3; j++) { ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(0, 20); ctx.stroke(); ctx.rotate(Math.PI / 3); } }
                    ctx.rotate(-(this.cloudOffset * 0.01 + i)); ctx.translate(-x, -y);
                }
                ctx.restore();
            }
            drawCloud(ctx, x, y) { ctx.beginPath(); ctx.arc(x, y, 30, 0, Math.PI * 2); ctx.arc(x + 25, y - 10, 35, 0, Math.PI * 2); ctx.arc(x + 50, y, 30, 0, Math.PI * 2); ctx.fill(); }
        }

        class Particle extends Entity {
            constructor(x, y, color = null) {
                const c = color || `hsl(${Math.random() * 360}, 100%, 50%)`; super(x, y, Math.random() * 5 + 2, Math.random() * 5 + 2, c); this.vx = (Math.random() - 0.5) * 10; this.vy = (Math.random() - 0.5) * 10; this.life = 1.0;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= 0.02; if (this.life <= 0) this.markedForDeletion = true; }
            draw(ctx) { ctx.globalAlpha = this.life; super.draw(ctx); ctx.globalAlpha = 1.0; }
        }

        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.currentDifficulty = 'normal';
                // DEFAULT CHAR: NARUTO, DEFAULT THEME: LEAF
                this.currentCharacter = 'naruto';
                this.currentTheme = 'leaf';
                this.username = "PLAYER";
                this.lastTime = 0; this.score = 0; this.lives = 1; this.knifeCount = 0; this.isRunning = false; this.isGameOver = false;
                this.bird = null; this.background = new Background(this.canvas.width, this.canvas.height);
                this.pipes = []; this.particles = []; this.powerups = []; this.enemies = []; this.projectiles = []; this.enemyProjectiles = []; this.hurtTimer = 0; this.mousePos = { x: 0, y: 0 }; this.speed = 3;
                this.scoreEl = document.getElementById('score-display'); this.livesEl = document.getElementById('lives-display'); this.knifeEl = document.getElementById('knife-display'); this.finalScoreEl = document.getElementById('final-score');
                this.startScreen = document.getElementById('start-screen'); this.gameOverScreen = document.getElementById('game-over-screen'); this.usernameInput = document.getElementById('username-input');
                this.currentMusic = null;
                this.setupInputs(); this.setupUI(); this.background.draw(this.ctx, this.currentTheme);
            }

            resize() {
                const container = this.canvas.parentElement; this.canvas.width = container.clientWidth; this.canvas.height = container.clientHeight;
                if (this.background) { this.background.width = this.canvas.width; this.background.height = this.canvas.height; }
            }

            setupUI() {
                document.querySelectorAll('#theme-selector .opt-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => { document.querySelectorAll('#theme-selector .opt-btn').forEach(b => b.classList.remove('selected')); e.target.classList.add('selected'); this.currentTheme = e.target.dataset.theme; this.background.draw(this.ctx, this.currentTheme); });
                });
                document.querySelectorAll('#char-selector .opt-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => { document.querySelectorAll('#char-selector .opt-btn').forEach(b => b.classList.remove('selected')); e.target.classList.add('selected'); this.currentCharacter = e.target.dataset.char; });
                });
                document.querySelectorAll('#diff-selector .opt-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => { document.querySelectorAll('#diff-selector .opt-btn').forEach(b => b.classList.remove('selected')); e.target.classList.add('selected'); this.currentDifficulty = e.target.dataset.diff; });
                });
                document.getElementById('start-btn').addEventListener('click', () => { if (this.usernameInput.value.trim() !== "") this.username = this.usernameInput.value.trim(); this.start(); });
                document.getElementById('restart-btn').addEventListener('click', () => { this.gameOverScreen.classList.add('hidden'); this.start(); });
                document.getElementById('menu-btn').addEventListener('click', () => { this.gameOverScreen.classList.add('hidden'); this.startScreen.classList.remove('hidden'); this.background.draw(this.ctx, this.currentTheme); });
            }

            setupInputs() {
                window.addEventListener('keydown', (e) => {
                    if (this.isRunning) {
                        if (e.code === 'Space') this.bird.flap();
                        if ((e.code === 'ShiftLeft' || e.code === 'ShiftRight') && !e.repeat) this.shoot();
                    }
                });
                this.canvas.addEventListener('touchstart', (e) => { if (this.isRunning) { e.preventDefault(); this.bird.flap(); } }, { passive: false });
                this.canvas.addEventListener('mousedown', (e) => { if (this.isRunning && e.button === 0) this.bird.flap(); });
                this.canvas.addEventListener('contextmenu', (e) => { e.preventDefault(); if (this.isRunning) this.shoot(); });
                const fireBtn = document.getElementById('fire-btn');
                fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); if (this.isRunning) this.shoot(); }, { passive: false });
                fireBtn.addEventListener('mousedown', (e) => { e.stopPropagation(); if (this.isRunning) this.shoot(); });
            }

            shoot() {
                if (this.knifeCount <= 0) return;
                this.knifeCount--; this.updateKnifeDisplay();

                let targetX = this.bird.x + 500; let targetY = this.bird.y + this.bird.height / 2;
                let closestEnemy = null; let minDistance = Infinity;
                this.enemies.forEach(enemy => {
                    if (enemy.x > this.bird.x) {
                        const dx = enemy.x - this.bird.x; const dy = enemy.y - this.bird.y; const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDistance) { minDistance = dist; closestEnemy = enemy; }
                    }
                });
                if (closestEnemy) { targetX = closestEnemy.x + closestEnemy.width / 2; targetY = closestEnemy.y + closestEnemy.height / 2; }

                this.projectiles.push(new Projectile(this.bird.x + this.bird.width, this.bird.y + this.bird.height / 2, targetX, targetY, this.currentTheme));
            }

            playThemeMusic() {
                this.stopMusic();
                const fileName = MUSIC_FILES[this.currentTheme];
                if (fileName) { this.currentMusic = new Audio(fileName); this.currentMusic.loop = true; this.currentMusic.volume = 0.4; this.currentMusic.play().catch(e => console.log("Audio play blocked:", e)); }
            }
            stopMusic() { if (this.currentMusic) { this.currentMusic.pause(); this.currentMusic.currentTime = 0; this.currentMusic = null; } }

            start() {
                this.bird = new Character(this.canvas.height, this.currentCharacter);
                this.pipes = []; this.particles = []; this.powerups = []; this.enemies = []; this.projectiles = []; this.enemyProjectiles = [];
                this.score = 0; this.knifeCount = 0;
                this.scoreEl.innerText = this.score;
                this.lives = 1;
                this.updateLivesDisplay(); this.updateKnifeDisplay();
                this.isRunning = true; this.isGameOver = false;
                this.startScreen.classList.add('hidden');
                this.lastTime = performance.now(); this.pipeTimer = 0;
                const diff = DIFFICULTIES[this.currentDifficulty]; this.speed = diff.speed;
                this.playThemeMusic();
                requestAnimationFrame((t) => this.loop(t));
            }

            updateLivesDisplay() { if (this.lives > 3) this.lives = 3; let hearts = ""; const icon = THEMES[this.currentTheme].lifeIcon; for (let i = 0; i < this.lives; i++) hearts += icon; this.livesEl.innerText = hearts; }
            updateKnifeDisplay() { this.knifeEl.innerText = `üî™ ${this.knifeCount}`; }

            loop(timestamp) { if (!this.isRunning) return; const dt = timestamp - this.lastTime; this.lastTime = timestamp; this.update(dt); this.draw(); if (!this.isGameOver) requestAnimationFrame((t) => this.loop(t)); }

            update(dt) {
                const diff = DIFFICULTIES[this.currentDifficulty];
                this.speed = diff.speed + (this.score * 0.02);

                this.background.update(this.speed);
                if (this.bird.update() === 'ground') this.endGame();

                this.projectiles.forEach(p => p.update());
                this.projectiles = this.projectiles.filter(p => !p.markedForDeletion);
                this.enemyProjectiles.forEach(p => p.update());
                this.enemyProjectiles = this.enemyProjectiles.filter(p => !p.markedForDeletion);

                if (this.enemies.length < 3) {
                    if (Math.random() < (diff.enemyChance + (this.score * 0.0003))) {
                        const y = Math.random() * (this.canvas.height - 200) + 50;
                        let type = 'normal';
                        if (this.score > 50) {
                            const r = Math.random();
                            if (r < 0.3) type = 'big';
                            else if (r < 0.6) type = 'shooter';
                        } else if (this.score > 10) {
                            if (Math.random() < 0.5) type = 'shooter';
                        }
                        this.enemies.push(new Enemy(this.canvas.width, y, this.currentTheme, type));
                    }
                }

                this.enemies.forEach(enemy => {
                    const shot = enemy.update();
                    if (shot === 'shoot') {
                        this.enemyProjectiles.push(new EnemyProjectile(enemy.x, enemy.y + enemy.height / 2));
                    }

                    if (!this.bird.invincible && this.bird.collidesWith(enemy)) { this.takeDamage(); enemy.markedForDeletion = true; }

                    this.projectiles.forEach(proj => {
                        if (proj.collidesWith(enemy)) {
                            proj.markedForDeletion = true;
                            enemy.health--;
                            enemy.hitFlash = 5;
                            if (enemy.health <= 0) {
                                enemy.markedForDeletion = true;
                                this.createExplosion(enemy.x, enemy.y, '#555');
                                this.score += 5; this.scoreEl.innerText = this.score;
                            }
                        }
                    });
                });
                this.enemies = this.enemies.filter(e => !e.markedForDeletion);

                this.projectiles.forEach(pProj => {
                    this.enemyProjectiles.forEach(eProj => {
                        if (pProj.collidesWith(eProj)) {
                            pProj.markedForDeletion = true; eProj.markedForDeletion = true;
                            this.createExplosion(eProj.x, eProj.y, 'orange');
                        }
                    });
                });

                this.enemyProjectiles.forEach(eProj => {
                    if (!this.bird.invincible && this.bird.collidesWith(eProj)) {
                        this.takeDamage(); eProj.markedForDeletion = true;
                    }
                });

                this.pipeTimer += dt;
                if (this.pipeTimer > diff.pipeInterval) { this.spawnPipe(diff.gap); this.pipeTimer = 0; }

                this.pipes.forEach(pipe => {
                    pipe.update(this.speed);
                    if (!this.bird.invincible && this.bird.collidesWith(pipe)) { this.takeDamage(); pipe.markedForDeletion = true; }
                    if (!pipe.passed && pipe.type === 'top' && pipe.x + pipe.width < this.bird.x) {
                        this.score++; this.scoreEl.innerText = this.score; pipe.passed = true;
                    }
                });
                this.pipes = this.pipes.filter(p => !p.markedForDeletion);

                this.powerups.forEach(p => {
                    p.update(this.speed);
                    if (this.bird.collidesWith(p)) {
                        this.knifeCount += 2; this.updateKnifeDisplay();

                        if (p.type === 'star') this.bird.activateStar();
                        if (p.type === 'life') { if (this.lives < 3) { this.lives++; this.updateLivesDisplay(); } }
                        p.markedForDeletion = true; this.createExplosion(p.x, p.y, p.type === 'life' ? 'red' : 'gold');
                    }
                });
                this.powerups = this.powerups.filter(p => !p.markedForDeletion);
                this.particles.forEach(p => p.update()); this.particles = this.particles.filter(p => !p.markedForDeletion);
            }

            takeDamage() {
                if (this.bird.invincible) return;
                this.lives--; this.updateLivesDisplay(); this.createExplosion(this.bird.x, this.bird.y);
                this.bird.velocity = -5; this.bird.activateStar(); this.bird.invincibleTimer = 60;
                if (this.lives <= 0) this.endGame();
            }

            createExplosion(x, y, color) { for (let i = 0; i < 15; i++) this.particles.push(new Particle(x, y, color)); }

            spawnPipe(gap) {
                const minHeight = 50; const groundHeight = 50; const availableHeight = this.canvas.height - groundHeight - gap - (minHeight * 2); const topHeight = Math.floor(Math.random() * availableHeight) + minHeight;
                this.pipes.push(new Pipe(this.canvas.width, 0, 60, topHeight, 'top', this.currentTheme));
                this.pipes.push(new Pipe(this.canvas.width, topHeight + gap, 60, this.canvas.height - groundHeight - topHeight - gap, 'bottom', this.currentTheme));

                const powerUpY = topHeight + (gap / 2) - 17; const powerUpX = this.canvas.width + 15;
                const chance = Math.random();
                if (chance < 0.2) this.powerups.push(new PowerUp(powerUpX, powerUpY, 'star', this.currentTheme));
                else if (chance > 0.2 && chance < 0.3) this.powerups.push(new PowerUp(powerUpX, powerUpY, 'life', this.currentTheme));
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.background.draw(this.ctx, this.currentTheme);
                this.pipes.forEach(pipe => pipe.draw(this.ctx));
                this.powerups.forEach(p => p.draw(this.ctx));
                this.enemies.forEach(e => e.draw(this.ctx));
                this.projectiles.forEach(p => p.draw(this.ctx));
                this.enemyProjectiles.forEach(p => p.draw(this.ctx));
                this.bird.draw(this.ctx);

                if (this.bird.invincible) {
                    const maxTime = 180; // UPDATED TO MATCH 3 SECONDS (180 FRAMES)
                    const currentTime = this.bird.invincibleTimer; const barWidth = this.canvas.width; const barHeight = 10;
                    const fillRatio = currentTime / maxTime; this.ctx.fillStyle = '#FFD700'; this.ctx.fillRect(0, 0, barWidth * fillRatio, barHeight);
                }
                this.particles.forEach(p => p.draw(this.ctx));
            }

            endGame() {
                this.isRunning = false; this.isGameOver = true; this.stopMusic();
                this.finalScoreEl.innerText = this.score; this.saveScore(); this.updateLeaderboard();
                this.gameOverScreen.classList.remove('hidden');
            }

            saveScore() {
                let scores = JSON.parse(localStorage.getItem('flappyScores')) || [];
                scores.push({ name: this.username, score: this.score, theme: this.currentTheme });
                scores.sort((a, b) => b.score - a.score); scores = scores.slice(0, 5);
                localStorage.setItem('flappyScores', JSON.stringify(scores));
            }

            updateLeaderboard() {
                const table = document.getElementById('leaderboard-table'); table.innerHTML = '';
                const scores = JSON.parse(localStorage.getItem('flappyScores')) || [];
                scores.forEach(s => { const row = document.createElement('tr'); row.innerHTML = `<td>${s.name}</td><td>${s.score}</td>`; table.appendChild(row); });
            }
        }

        const game = new Game('gameCanvas');

    </script>
</body>

</html>