<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy All-Stars & Themes</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            height: 100%;
            max-height: 800px;
            background-color: #70c5ce;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        #score-display {
            position: absolute;
            top: 10%;
            font-size: 3rem;
            color: white;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }

        #lives-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5rem;
            color: #ff4444;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
            text-align: left;
        }

        #start-screen, #game-over-screen {
            background: rgba(0, 0, 0, 0.9);
            padding: 1.5rem;
            border-radius: 10px;
            pointer-events: auto;
            color: white;
            border: 2px solid white;
            width: 90%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #f4ce42;
            text-shadow: 3px 3px 0 #000;
        }

        p {
            font-size: 0.7rem;
            margin-bottom: 0.5rem;
            line-height: 1.5;
            color: #aaa;
        }

        input[type="text"] {
            background: #333;
            border: 2px solid #fff;
            color: #fff;
            padding: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            width: 100%;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .btn {
            background: #e06018;
            border: 2px solid white;
            color: white;
            padding: 12px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 4px 4px 0 #000;
            transition: transform 0.1s;
            margin-top: 10px;
            width: 100%;
        }

        .btn-secondary {
            background: #444;
            margin-top: 10px;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #000;
        }

        .selector-label {
            margin-top: 10px;
            color: #fff;
            text-transform: uppercase;
            font-size: 0.7rem;
            text-align: left;
        }

        .option-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .opt-btn {
            padding: 8px 2px;
            font-size: 0.5rem;
            background: #444;
            border: 2px solid #777;
            color: #ccc;
            cursor: pointer;
            box-shadow: 2px 2px 0 #000;
        }

        .opt-btn.selected {
            background: #73bf2e;
            border-color: #fff;
            color: #fff;
            transform: scale(1.05);
        }
        
        /* Character Highlights */
        .opt-btn[data-char="cartman"].selected { background: #E74C3C; }
        .opt-btn[data-char="naruto"].selected { background: #F39C12; }
        .opt-btn[data-char="killua"].selected { background: #95A5A6; }
        .opt-btn[data-char="stalin"].selected { background: #6E2C00; }
        .opt-btn[data-char="mussolini"].selected { background: #212F3C; }
        .opt-btn[data-char="kim"].selected { background: #333; }

        /* Theme Highlights */
        .opt-btn[data-theme="soviet"].selected { background: #C0392B; }
        .opt-btn[data-theme="leaf"].selected { background: #58D68D; color: #000; }
        .opt-btn[data-theme="southpark"].selected { background: #AED6F1; color: #000; }

        .leaderboard-container {
            margin-top: 15px;
            width: 100%;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        
        table {
            width: 100%;
            font-size: 0.6rem;
            color: #ccc;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 5px;
            text-align: left;
            border-bottom: 1px solid #444;
        }
        
        td:last-child {
            text-align: right;
            color: #f4ce42;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="score-display">0</div>
    <div id="lives-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>

    <div id="ui-layer">
        <div id="start-screen">
            <h1>FLAPPY ALL-STARS</h1>
            
            <input type="text" id="username-input" placeholder="ENTER NAME" maxlength="8">

            <p class="selector-label">Theme</p>
            <div class="option-grid" id="theme-selector">
                <button class="opt-btn" data-theme="soviet">SOVIET</button>
                <button class="opt-btn selected" data-theme="leaf">LEAF</button>
                <button class="opt-btn" data-theme="southpark">S. PARK</button>
            </div>

            <p class="selector-label">Character</p>
            <div class="option-grid" id="char-selector">
                <button class="opt-btn selected" data-char="cartman">CARTMAN</button>
                <button class="opt-btn" data-char="naruto">NARUTO</button>
                <button class="opt-btn" data-char="killua">KILLUA</button>
                <button class="opt-btn" data-char="stalin">STALIN</button>
                <button class="opt-btn" data-char="mussolini">MUSSOLINI</button>
                <button class="opt-btn" data-char="kim">KIM</button>
            </div>

            <p class="selector-label">Difficulty</p>
            <div class="option-grid" id="diff-selector">
                <button class="opt-btn" data-diff="easy">EASY</button>
                <button class="opt-btn selected" data-diff="normal">NORMAL</button>
                <button class="opt-btn" data-diff="hard">HARD</button>
            </div>

            <button id="start-btn" class="btn">START GAME</button>
            <p style="margin-top:10px; font-size: 0.5rem; color: #ff6666;">*Right-click to shoot in Normal/Hard*</p>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1>GAME OVER</h1>
            <p>Score: <span id="final-score">0</span></p>
            
            <div class="leaderboard-container">
                <p>LEADERBOARD</p>
                <table id="leaderboard-table">
                    </table>
            </div>

            <button id="restart-btn" class="btn">TRY AGAIN</button>
            <button id="menu-btn" class="btn btn-secondary">CHANGE SETTINGS</button>
        </div>
    </div>
</div>

<script>

/* --------------------------------------------------------
   MUSIK KONFIGURATION
   √Ñndra filnamnen h√§r nedanf√∂r f√∂r att matcha dina mp3-filer.
   Se till att filerna ligger i samma mapp som denna HTML-fil.
   --------------------------------------------------------
*/
const MUSIC_FILES = {
    soviet: 'audio/soviet-theme.mp3',      // Byt namn om din fil heter n√•got annat
    leaf: 'audio/naruto-theme.mp3',          // Byt namn om din fil heter n√•got annat
    southpark: 'audio/south-park-theme.mp3' // Byt namn om din fil heter n√•got annat
};

/**
 * Game Configuration
 */
const DIFFICULTIES = {
    easy: { 
        speed: 2.5, 
        pipeInterval: 2200, 
        gap: 150, 
        enemyChance: 0 
    },
    normal: { 
        speed: 3, 
        pipeInterval: 1700, 
        gap: 170, 
        enemyChance: 0.04 
    },
    hard: { 
        speed: 4, 
        pipeInterval: 1400, 
        gap: 150, 
        enemyChance: 0.08
    }
};

const THEMES = {
    soviet: {
        bgSky: '#5D6D7E', 
        bgGround: '#2C3E50', 
        pipeMain: '#5D6D7E',
        pipeStroke: '#17202A',
        clouds: false,
        factories: true,
        mountains: false,
        lifeIcon: '‚≠ê'
    },
    leaf: {
        bgSky: '#85C1E9', 
        bgGround: '#58D68D', 
        pipeMain: '#A04000', // Wood
        pipeStroke: '#6E2C00',
        clouds: true,
        factories: false,
        mountains: false,
        lifeIcon: 'üçú'
    },
    southpark: {
        bgSky: '#AED6F1', 
        bgGround: '#FBFCFC', // Snow
        pipeMain: '#2ECC71',
        pipeStroke: '#27AE60',
        clouds: true,
        factories: false,
        mountains: true,
        lifeIcon: 'üßÄ'
    }
};

const CHARACTERS = {
    cartman: { color: '#E74C3C', hat: '#3498DB', face: '#F5CBA7' },
    naruto: { color: '#F39C12', hair: '#F1C40F', face: '#F5CBA7' },
    killua: { color: '#34495E', hair: '#ECF0F1', face: '#FDFEFE' },
    stalin: { color: '#6E2C00', uniform: '#D4AC0D', face: '#F5CBA7' },
    mussolini: { color: '#212F3C', uniform: '#212F3C', face: '#F5CBA7' },
    kim: { color: '#2C3E50', suit: '#2C3E50', face: '#F5CBA7' }
};

/**
 * Base Entity
 */
class Entity {
    constructor(x, y, width, height, color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.color = color;
        this.markedForDeletion = false;
    }
    update() {}
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    collidesWith(other) {
        const padding = 4;
        return (
            this.x + padding < other.x + other.width - padding &&
            this.x + this.width - padding > other.x + padding &&
            this.y + padding < other.y + other.height - padding &&
            this.y + this.height - padding > other.y + padding
        );
    }
}

/**
 * Projectile Class
 */
class Projectile extends Entity {
    constructor(x, y, targetX, targetY, theme) {
        super(x, y, 15, 15, '#fff');
        this.theme = theme;
        this.speed = 8;
        
        // Calculate velocity vector
        const dx = targetX - x;
        const dy = targetY - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        this.vx = (dx / dist) * this.speed;
        this.vy = (dy / dist) * this.speed;
        
        this.rotation = 0;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += 0.2;
        
        // Remove if off screen
        if (this.x < 0 || this.x > 2000 || this.y < 0 || this.y > 2000) {
            this.markedForDeletion = true;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        if (this.theme === 'soviet') {
            // Sickle
            ctx.strokeStyle = '#C0392B';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0.5, Math.PI * 1.5);
            ctx.stroke();
            ctx.fillStyle = '#C0392B';
            ctx.fillRect(-2, 0, 4, 10);
        } else if (this.theme === 'leaf') {
            // Kunai / Shuriken
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.moveTo(0, -8); ctx.lineTo(6, 0);
            ctx.lineTo(0, 8); ctx.lineTo(-6, 0);
            ctx.fill();
        } else {
            // Snowball
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
}

/**
 * Enemy Class
 */
class Enemy extends Entity {
    constructor(x, y, theme) {
        super(x, y, 40, 40, '#000');
        this.theme = theme;
        this.vx = Math.random() * 2 + 1; // Speed
        this.wobble = Math.random() * Math.PI * 2;
    }

    update() {
        this.x -= this.vx;
        this.wobble += 0.1;
        this.y += Math.sin(this.wobble) * 2;
        
        if (this.x + this.width < 0) this.markedForDeletion = true;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + 20, this.y + 20);
        
        if (this.theme === 'soviet') {
            // The Capitalist
            ctx.fillStyle = '#000'; // Suit
            ctx.fillRect(-15, 0, 30, 20);
            ctx.fillStyle = '#F5CBA7'; // Face
            ctx.beginPath(); ctx.arc(0, -5, 15, 0, Math.PI*2); ctx.fill();
            // Top Hat
            ctx.fillStyle = '#17202A';
            ctx.fillRect(-15, -25, 30, 15);
            ctx.fillRect(-20, -10, 40, 5);
            // Monocle
            ctx.strokeStyle = '#F1C40F';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(5, -5, 5, 0, Math.PI*2); ctx.stroke();
            
        } else if (this.theme === 'leaf') {
            // Rogue Ninja
            ctx.fillStyle = '#212F3C'; // Dark cloak
            ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#F5CBA7'; // Face
            ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
            // Mask
            ctx.fillStyle = '#17202A';
            ctx.fillRect(-10, 2, 20, 10);
            // Scratch on headband
            ctx.fillStyle = '#7F8C8D'; ctx.fillRect(-12, -12, 24, 6);
            ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.moveTo(-5, -12); ctx.lineTo(5, -6); ctx.stroke();

        } else {
            // Professor Chaos (South Park)
            ctx.fillStyle = '#D7DBDD'; // Foil
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#F5CBA7'; // Face hole
            ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(-4, 0, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(4, 0, 2, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

/**
 * PowerUp Class
 */
class PowerUp extends Entity {
    constructor(x, y, type, theme) {
        super(x, y, 35, 35, type === 'life' ? 'red' : 'gold');
        this.type = type; 
        this.theme = theme;
        this.initialY = y;
        this.angle = 0;
    }

    update(speed) {
        this.x -= speed;
        this.angle += 0.1;
        this.y = this.initialY + Math.sin(this.angle) * 20;
        if (this.x + this.width < 0) this.markedForDeletion = true;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        
        if (this.theme === 'soviet') {
            if (this.type === 'life') {
                this.drawStar(ctx, 0, 0, 5, 15, 7, '#E74C3C', '#C0392B');
            } else {
                ctx.rotate(Math.sin(this.angle));
                ctx.fillStyle = '#F1C40F';
                ctx.fillRect(-4, -10, 8, 20); ctx.fillRect(-10, -12, 20, 8);
            }
        } else if (this.theme === 'leaf') {
            if (this.type === 'life') {
                ctx.fillStyle = '#E59866'; ctx.beginPath(); ctx.arc(0, 5, 15, 0, Math.PI); ctx.fill();
                ctx.fillStyle = '#F7DC6F'; ctx.beginPath(); ctx.ellipse(0, 5, 14, 4, 0, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.rotate(this.angle * 2);
                ctx.fillStyle = '#5D6D7E';
                ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(4, -4); ctx.lineTo(15, 0); ctx.lineTo(4, 4);
                ctx.lineTo(0, 15); ctx.lineTo(-4, 4); ctx.lineTo(-15, 0); ctx.lineTo(-4, -4); ctx.fill();
            }
        } else if (this.theme === 'southpark') {
            if (this.type === 'life') {
                ctx.fillStyle = '#FF7F50'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#C0392B'; for(let i=0; i<5; i++) { ctx.beginPath(); ctx.arc(Math.random()*20-10, Math.random()*20-10, 2, 0, Math.PI*2); ctx.fill(); }
            } else {
                ctx.rotate(this.angle); ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
                for(let i=0; i<3; i++) { ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(0, 15); ctx.stroke(); ctx.rotate(Math.PI/3); }
            }
        }
        ctx.restore();
    }

    drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, fill, stroke) {
        let rot = Math.PI / 2 * 3;
        let x = cx, y = cy, step = Math.PI / spikes;
        ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step;
            x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius); ctx.closePath();
        ctx.lineWidth = 2; ctx.strokeStyle = stroke; ctx.stroke(); ctx.fillStyle = fill; ctx.fill();
    }
}

/**
 * Character Class
 */
class Character extends Entity {
    constructor(gameHeight, type = 'cartman') {
        super(50, gameHeight / 2, 40, 40, CHARACTERS[type].color);
        this.type = type;
        this.velocity = 0;
        this.gravity = 0.5; 
        this.jumpStrength = -8; 
        this.rotation = 0;
        this.gameHeight = gameHeight;
        this.invincible = false;
        this.invincibleTimer = 0;
        this.hue = 0;
    }

    flap() {
        this.velocity = this.jumpStrength;
    }

    activateStar() {
        this.invincible = true;
        this.invincibleTimer = 300; 
    }

    update() {
        this.velocity += this.gravity;
        this.y += this.velocity;

        if (this.velocity < 0) {
            this.rotation = -25 * (Math.PI / 180);
        } else {
            this.rotation += 2 * (Math.PI / 180);
            if(this.rotation > 90 * (Math.PI / 180)) this.rotation = 90 * (Math.PI / 180);
        }

        if (this.invincible) {
            this.invincibleTimer--;
            this.hue += 10;
            if (this.invincibleTimer <= 0) {
                this.invincible = false;
            }
        }

        if (this.y + this.height > this.gameHeight - 50) {
            this.y = this.gameHeight - 50 - this.height;
            return 'ground';
        }
        if (this.y < 0) {
            this.y = 0;
            this.velocity = 0;
        }
        return false;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        ctx.rotate(this.rotation);

        let config = CHARACTERS[this.type];
        
        if (this.invincible) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
        }

        this.drawSpecificCharacter(ctx, config);
        ctx.restore();
    }

    drawSpecificCharacter(ctx, config) {
        ctx.fillStyle = config.face;
        
        if (this.type === 'cartman') {
            ctx.fillStyle = config.color; 
            ctx.beginPath(); ctx.arc(0, 10, 22, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = config.face;
            ctx.beginPath(); ctx.arc(0, -5, 18, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(0, 5, 10, 0, Math.PI); ctx.stroke();
            ctx.fillStyle = config.hat; 
            ctx.beginPath(); ctx.arc(0, -10, 19, Math.PI, 0); ctx.fill();
            ctx.fillStyle = '#F1C40F';
            ctx.beginPath(); ctx.ellipse(0, -28, 5, 3, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-18, -10); ctx.lineTo(18, -10); ctx.stroke();
        } else if (this.type === 'naruto') {
            ctx.fillStyle = config.color; 
            ctx.fillRect(-15, 10, 30, 20);
            ctx.fillStyle = config.face;
            ctx.beginPath(); ctx.arc(0, -5, 16, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = config.hair;
            ctx.beginPath();
            for(let i=0; i<7; i++) { ctx.lineTo(-20 + (i*6), -30 + (Math.random()*10)); ctx.lineTo(-17 + (i*6), -15); }
            ctx.fill();
            ctx.fillStyle = '#2C3E50'; ctx.fillRect(-16, -18, 32, 6);
            ctx.fillStyle = '#95A5A6'; ctx.fillRect(-8, -17, 16, 4);
            ctx.strokeStyle = '#000'; ctx.beginPath();
            ctx.moveTo(-12, -2); ctx.lineTo(-6, -1); ctx.moveTo(-12, 1); ctx.lineTo(-6, 2); ctx.moveTo(-12, 4); ctx.lineTo(-6, 5);
            ctx.moveTo(12, -2); ctx.lineTo(6, -1); ctx.moveTo(12, 1); ctx.lineTo(6, 2); ctx.moveTo(12, 4); ctx.lineTo(6, 5);
            ctx.stroke();
        } else if (this.type === 'killua') {
            ctx.fillStyle = config.color; ctx.fillRect(-15, 10, 30, 20);
            ctx.fillStyle = config.face; ctx.beginPath(); ctx.arc(0, -5, 15, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = config.hair; ctx.beginPath();
            ctx.moveTo(-20, -10); ctx.lineTo(-25, -25); ctx.lineTo(-10, -15); ctx.lineTo(0, -30);
            ctx.lineTo(10, -15); ctx.lineTo(25, -25); ctx.lineTo(20, -10); ctx.fill();
            ctx.fillStyle = '#2E86C1'; ctx.beginPath();
            ctx.ellipse(-6, -2, 4, 2, 0.2, 0, Math.PI*2); ctx.ellipse(6, -2, 4, 2, -0.2, 0, Math.PI*2); ctx.fill();
        } else if (this.type === 'stalin') {
            ctx.fillStyle = config.color; ctx.fillRect(-18, 8, 36, 22);
            ctx.fillStyle = config.face; ctx.fillRect(-15, -20, 30, 30);
            ctx.fillStyle = '#212121'; ctx.beginPath();
            ctx.moveTo(-15, -15); ctx.quadraticCurveTo(0, -25, 15, -15); ctx.lineTo(15, -22); ctx.quadraticCurveTo(0, -32, -15, -22); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath();
            ctx.moveTo(-10, 5); ctx.quadraticCurveTo(0, 0, 10, 5); ctx.quadraticCurveTo(12, 8, 8, 8); ctx.quadraticCurveTo(0, 5, -8, 8); ctx.quadraticCurveTo(-12, 8, -10, 5); ctx.fill();
        } else if (this.type === 'mussolini') {
            ctx.fillStyle = config.color; ctx.fillRect(-18, 8, 36, 22);
            ctx.fillStyle = config.face; ctx.beginPath(); ctx.ellipse(0, -8, 16, 18, 0, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#D68910'; ctx.beginPath(); ctx.arc(0, 8, 5, 0, Math.PI); ctx.stroke();
        } else if (this.type === 'kim') {
            ctx.fillStyle = config.suit; ctx.fillRect(-18, 8, 36, 22);
            ctx.fillStyle = config.face; ctx.beginPath(); ctx.arc(0, -5, 18, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.fillRect(-18, -25, 36, 10);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.beginPath();
            ctx.moveTo(-12, -5); ctx.lineTo(-2, -5); ctx.moveTo(2, -5); ctx.lineTo(12, -5); ctx.stroke();
        }

        if (this.type !== 'killua') {
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-6, -5, 4, 0, Math.PI*2); ctx.arc(6, -5, 4, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-5, -5, 2, 0, Math.PI*2); ctx.arc(7, -5, 2, 0, Math.PI*2); ctx.fill();
        }
    }
}

class Pipe extends Entity {
    constructor(x, y, width, height, type, theme) {
        super(x, y, width, height, '#73bf2e');
        this.type = type;
        this.theme = theme;
        this.passed = false;
        this.mainColor = THEMES[theme].pipeMain;
        this.strokeColor = THEMES[theme].pipeStroke;
    }

    update(speed) {
        this.x -= speed;
        if (this.x + this.width < 0) this.markedForDeletion = true;
    }

    draw(ctx) {
        ctx.fillStyle = this.mainColor;
        ctx.strokeStyle = this.strokeColor;
        ctx.lineWidth = 2;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.strokeRect(this.x, this.y, this.width, this.height);

        const capHeight = 20;
        const capExtension = 4;
        let capY = this.type === 'top' ? this.y + this.height - capHeight : this.y;
        ctx.fillRect(this.x - capExtension, capY, this.width + (capExtension*2), capHeight);
        ctx.strokeRect(this.x - capExtension, capY, this.width + (capExtension*2), capHeight);
        
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#000';
        if(this.theme === 'leaf') {
             ctx.beginPath(); ctx.arc(this.x+30, this.y+30, 10, 0, Math.PI*2); ctx.fill();
        } else if (this.theme === 'soviet') {
             ctx.fillRect(this.x+5, capY+5, 4, 4);
             ctx.fillRect(this.x+this.width-9, capY+5, 4, 4);
        }
        ctx.globalAlpha = 1.0;
    }
}

class Background {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.cloudOffset = 0;
        this.groundOffset = 0;
        this.decorations = []; // For floating weapons
    }

    update(speed) {
        this.cloudOffset -= speed * 0.2;
        if (this.cloudOffset <= -this.width) this.cloudOffset = 0;
        this.groundOffset -= speed;
        if (this.groundOffset <= -20) this.groundOffset = 0;
    }

    draw(ctx, themeName) {
        const theme = THEMES[themeName];
        ctx.fillStyle = theme.bgSky;
        ctx.fillRect(0, 0, this.width, this.height);

        // Draw Floating Decorations (Weapons)
        this.drawDecorations(ctx, themeName);

        if (theme.clouds) {
             ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
             for(let i=0; i<5; i++) {
                let xPos = (i * 200 + this.cloudOffset) % (this.width + 200);
                if(xPos < -100) xPos += this.width + 200;
                this.drawCloud(ctx, xPos, 100 + (i%2)*50);
             }
        }
        
        if (theme.mountains) {
             ctx.fillStyle = '#ECF0F1';
             for(let i=0; i<5; i++) {
                 let x = (i * 150 + this.cloudOffset * 0.5) % (this.width + 300);
                 if(x < -150) x += this.width + 300;
                 ctx.beginPath(); ctx.moveTo(x, this.height-50); ctx.lineTo(x+100, this.height-250); ctx.lineTo(x+200, this.height-50); ctx.fill();
             }
        }

        if (theme.factories) {
            ctx.fillStyle = '#2C3E50';
             for(let i=0; i<6; i++) {
                let x = (i * 120 + this.cloudOffset * 0.5) % (this.width + 120);
                if(x < -100) x += this.width + 120;
                ctx.fillRect(x, this.height - 150 - (i%2)*30, 60, 200);
                ctx.fillStyle = '#F4D03F'; ctx.fillRect(x+10, this.height - 120, 10, 10); ctx.fillStyle = '#2C3E50';
             }
        }

        ctx.fillStyle = theme.bgGround; ctx.fillRect(0, this.height - 50, this.width, 50);
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(0, this.height - 50, this.width, 5);
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        for(let i=0; i < this.width + 20; i+=20) {
            ctx.beginPath();
            ctx.moveTo(i + this.groundOffset, this.height - 50); ctx.lineTo(i + this.groundOffset - 15, this.height);
            ctx.lineTo(i + this.groundOffset - 10, this.height); ctx.lineTo(i + this.groundOffset + 5, this.height - 50);
            ctx.fill();
        }
    }

    drawDecorations(ctx, theme) {
        // Draw some static decorations that move with parallax
        ctx.save();
        ctx.globalAlpha = 0.4; // Faint in background
        for(let i=0; i<6; i++) {
            let x = (i * 250 + this.cloudOffset * 0.8) % (this.width + 250);
            if(x < -100) x += this.width + 250;
            let y = 100 + (i * 50) % 300;
            
            ctx.translate(x, y);
            ctx.rotate(this.cloudOffset * 0.01 + i); // Rotate slowly
            
            if (theme === 'soviet') {
                // Background Sickle
                ctx.strokeStyle = '#922B21'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.arc(0, 0, 20, 0.5, Math.PI * 1.5); ctx.stroke();
                ctx.fillStyle = '#922B21'; ctx.fillRect(-5, 0, 8, 20);
            } else if (theme === 'leaf') {
                // Background Kunai
                ctx.fillStyle = '#34495E';
                ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(8, 0); ctx.lineTo(0, 20); ctx.lineTo(-8, 0); ctx.fill();
            } else if (theme === 'southpark') {
                // Background Snowflake
                ctx.strokeStyle = '#D6EAF8'; ctx.lineWidth = 4;
                for(let j=0; j<3; j++) { ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(0, 20); ctx.stroke(); ctx.rotate(Math.PI/3); }
            }
            ctx.rotate(-(this.cloudOffset * 0.01 + i)); // Reset rotation
            ctx.translate(-x, -y);
        }
        ctx.restore();
    }

    drawCloud(ctx, x, y) {
        ctx.beginPath();
        ctx.arc(x, y, 30, 0, Math.PI * 2);
        ctx.arc(x + 25, y - 10, 35, 0, Math.PI * 2);
        ctx.arc(x + 50, y, 30, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Particle extends Entity {
    constructor(x, y, color = null) {
        const c = color || `hsl(${Math.random()*360}, 100%, 50%)`;
        super(x, y, Math.random() * 5 + 2, Math.random() * 5 + 2, c);
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.life = 1.0;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.life -= 0.02;
        if(this.life <= 0) this.markedForDeletion = true;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life; super.draw(ctx); ctx.globalAlpha = 1.0;
    }
}

/**
 * GAME CONTROLLER
 */
class Game {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.currentDifficulty = 'normal';
        this.currentCharacter = 'cartman';
        this.currentTheme = 'leaf';
        this.username = "PLAYER";
        
        this.lastTime = 0;
        this.score = 0;
        this.lives = 1;
        this.isRunning = false;
        this.isGameOver = false;
        
        this.bird = null;
        this.background = new Background(this.canvas.width, this.canvas.height);
        this.pipes = [];
        this.particles = [];
        this.powerups = [];
        this.enemies = []; // Store enemies
        this.projectiles = []; // Store aimed shots
        this.hurtTimer = 0;
        
        // Track mouse position for keyboard shooting
        this.mousePos = { x: 0, y: 0 };

        this.speed = 3;

        this.scoreEl = document.getElementById('score-display');
        this.livesEl = document.getElementById('lives-display');
        this.finalScoreEl = document.getElementById('final-score');
        this.startScreen = document.getElementById('start-screen');
        this.gameOverScreen = document.getElementById('game-over-screen');
        this.usernameInput = document.getElementById('username-input');

        // AUDIO SETUP
        this.currentMusic = null;

        this.setupInputs();
        this.setupUI();
        this.background.draw(this.ctx, this.currentTheme);
    }

    resize() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        if (this.background) {
            this.background.width = this.canvas.width;
            this.background.height = this.canvas.height;
        }
    }

    setupUI() {
        // Theme Selectors
        document.querySelectorAll('#theme-selector .opt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('#theme-selector .opt-btn').forEach(b => b.classList.remove('selected'));
                e.target.classList.add('selected');
                this.currentTheme = e.target.dataset.theme;
                // Redraw background preview
                this.background.draw(this.ctx, this.currentTheme);
            });
        });

        // Character Selectors
        document.querySelectorAll('#char-selector .opt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('#char-selector .opt-btn').forEach(b => b.classList.remove('selected'));
                e.target.classList.add('selected');
                this.currentCharacter = e.target.dataset.char;
            });
        });

        // Difficulty Selectors
        document.querySelectorAll('#diff-selector .opt-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('#diff-selector .opt-btn').forEach(b => b.classList.remove('selected'));
                e.target.classList.add('selected');
                this.currentDifficulty = e.target.dataset.diff;
            });
        });

        document.getElementById('start-btn').addEventListener('click', () => {
            if(this.usernameInput.value.trim() !== "") this.username = this.usernameInput.value.trim();
            this.start();
        });

        document.getElementById('restart-btn').addEventListener('click', () => {
            this.gameOverScreen.classList.add('hidden');
            this.start();
        });

        document.getElementById('menu-btn').addEventListener('click', () => {
            this.gameOverScreen.classList.add('hidden');
            this.startScreen.classList.remove('hidden');
            this.background.draw(this.ctx, this.currentTheme);
        });
    }

    setupInputs() {
        // Flap controls
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && this.isRunning) {
                this.bird.flap();
            }
        });
        
        this.canvas.addEventListener('touchstart', (e) => {
            if (this.isRunning) {
                e.preventDefault();
                this.bird.flap();
            }
        }, {passive: false});

        this.canvas.addEventListener('mousedown', (e) => {
             if (this.isRunning && e.button === 0) { // Left click only
                this.bird.flap();
            }
        });

        // Track Mouse for aiming
        this.canvas.addEventListener('mousemove', (e) => {
            const rect = this.canvas.getBoundingClientRect();
            this.mousePos.x = e.clientX - rect.left;
            this.mousePos.y = e.clientY - rect.top;
        });

        // Shoot controls (Right Click)
        this.canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Block context menu
            if(this.isRunning && (this.currentDifficulty === 'normal' || this.currentDifficulty === 'hard')) {
                this.shoot();
            }
        });
    }

    shoot() {
        // Add recoil or cooldown if desired
        const projectile = new Projectile(
            this.bird.x + this.bird.width, 
            this.bird.y + this.bird.height/2, 
            this.mousePos.x, 
            this.mousePos.y,
            this.currentTheme
        );
        this.projectiles.push(projectile);
    }

    playThemeMusic() {
        // Stop any currently playing music
        this.stopMusic();

        const fileName = MUSIC_FILES[this.currentTheme];
        if (fileName) {
            this.currentMusic = new Audio(fileName);
            this.currentMusic.loop = true;
            this.currentMusic.volume = 0.4; // S√§tt volym (0.0 till 1.0)
            
            this.currentMusic.play().catch(e => {
                console.log("Audio play blocked (user interaction needed first):", e);
            });
        }
    }

    stopMusic() {
        if (this.currentMusic) {
            this.currentMusic.pause();
            this.currentMusic.currentTime = 0;
            this.currentMusic = null;
        }
    }

    start() {
        this.bird = new Character(this.canvas.height, this.currentCharacter);
        this.pipes = [];
        this.particles = [];
        this.powerups = [];
        this.enemies = [];
        this.projectiles = [];
        this.score = 0;
        this.scoreEl.innerText = this.score;
        this.lives = 1;
        this.updateLivesDisplay();
        this.isRunning = true;
        this.isGameOver = false;
        this.startScreen.classList.add('hidden');
        this.lastTime = performance.now();
        this.pipeTimer = 0;
        
        // Settings from difficulty
        const diff = DIFFICULTIES[this.currentDifficulty];
        this.speed = diff.speed;
        
        // Play music
        this.playThemeMusic();

        requestAnimationFrame((t) => this.loop(t));
    }

    updateLivesDisplay() {
        let hearts = "";
        const icon = THEMES[this.currentTheme].lifeIcon;
        for(let i=0; i<this.lives; i++) hearts += icon;
        this.livesEl.innerText = hearts;
    }

    loop(timestamp) {
        if (!this.isRunning) return;

        const dt = timestamp - this.lastTime;
        this.lastTime = timestamp;

        this.update(dt);
        this.draw();

        if (!this.isGameOver) {
            requestAnimationFrame((t) => this.loop(t));
        }
    }

    update(dt) {
        // Update Background (Parallax)
        this.background.update(this.speed);

        // Update Bird
        const collision = this.bird.update();
        if (collision === 'ground') {
            this.endGame();
        }

        // Update Projectiles
        this.projectiles.forEach(p => p.update());
        this.projectiles = this.projectiles.filter(p => !p.markedForDeletion);

        // Enemies Spawning
        const diff = DIFFICULTIES[this.currentDifficulty];
        if (Math.random() < diff.enemyChance) {
             // Spawn enemy at right edge at random height
             const y = Math.random() * (this.canvas.height - 200) + 50;
             this.enemies.push(new Enemy(this.canvas.width, y, this.currentTheme));
        }

        // Update Enemies
        this.enemies.forEach(enemy => {
            enemy.update();
            // Collision Bird vs Enemy
            if (!this.bird.invincible && this.bird.collidesWith(enemy)) {
                this.takeDamage();
                enemy.markedForDeletion = true; 
            }
            // Collision Projectile vs Enemy
            this.projectiles.forEach(proj => {
                if(proj.collidesWith(enemy)) {
                    enemy.markedForDeletion = true;
                    proj.markedForDeletion = true;
                    this.createExplosion(enemy.x, enemy.y, '#555');
                    this.score += 5; // Bonus points for killing
                    this.scoreEl.innerText = this.score;
                }
            });
        });
        this.enemies = this.enemies.filter(e => !e.markedForDeletion);

        // Spawn Pipes
        this.pipeTimer += dt;
        if (this.pipeTimer > diff.pipeInterval) {
            this.spawnPipe(diff.gap);
            this.pipeTimer = 0;
        }

        // Update Pipes
        this.pipes.forEach(pipe => {
            pipe.update(this.speed);

            if (!this.bird.invincible && this.bird.collidesWith(pipe)) {
                this.takeDamage();
                pipe.markedForDeletion = true; // Remove pipe so we don't get stuck inside
            }

            if (!pipe.passed && pipe.x + pipe.width < this.bird.x) {
                this.score++;
                this.scoreEl.innerText = this.score;
                pipe.passed = true;
                
                // Spawn Powerup logic?
                if(this.score % 10 === 0 && pipe.type === 'top') { // Every 10 points
                     this.powerups.push(new PowerUp(pipe.x, pipe.y + pipe.height + 50, 'star', this.currentTheme));
                }
                if(this.score % 15 === 0 && pipe.type === 'top') { // Every 15 points rare life
                     this.powerups.push(new PowerUp(pipe.x, pipe.y + pipe.height + 50, 'life', this.currentTheme));
                }
            }
        });
        this.pipes = this.pipes.filter(p => !p.markedForDeletion);

        // Update Powerups
        this.powerups.forEach(p => {
            p.update(this.speed);
            if(this.bird.collidesWith(p)) {
                if(p.type === 'star') this.bird.activateStar();
                if(p.type === 'life') { this.lives++; this.updateLivesDisplay(); }
                p.markedForDeletion = true;
                this.createExplosion(p.x, p.y, p.type === 'life' ? 'red' : 'gold');
            }
        });
        this.powerups = this.powerups.filter(p => !p.markedForDeletion);

        // Particles
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => !p.markedForDeletion);
    }

    takeDamage() {
        if(this.bird.invincible) return;

        this.lives--;
        this.updateLivesDisplay();
        this.createExplosion(this.bird.x, this.bird.y);
        
        // Push bird back/up slightly
        this.bird.velocity = -5;
        this.bird.activateStar(); // Give short i-frames (reuse star logic but manually set time maybe? kept simple here)
        this.bird.invincibleTimer = 60; // 1 second if 60fps

        if(this.lives <= 0) {
            this.endGame();
        }
    }

    createExplosion(x, y, color) {
        for(let i=0; i<15; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    spawnPipe(gap) {
        const minHeight = 50;
        const groundHeight = 50;
        const availableHeight = this.canvas.height - groundHeight - gap - (minHeight * 2);
        const topHeight = Math.floor(Math.random() * availableHeight) + minHeight;

        this.pipes.push(new Pipe(this.canvas.width, 0, 60, topHeight, 'top', this.currentTheme));
        this.pipes.push(new Pipe(this.canvas.width, topHeight + gap, 60, this.canvas.height - groundHeight - topHeight - gap, 'bottom', this.currentTheme));
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.background.draw(this.ctx, this.currentTheme);
        
        this.pipes.forEach(pipe => pipe.draw(this.ctx));
        this.powerups.forEach(p => p.draw(this.ctx));
        this.enemies.forEach(e => e.draw(this.ctx));
        this.projectiles.forEach(p => p.draw(this.ctx));
        this.bird.draw(this.ctx);
        this.particles.forEach(p => p.draw(this.ctx));
    }

    endGame() {
        this.isRunning = false;
        this.isGameOver = true;
        this.stopMusic(); // Stop music on game over
        this.finalScoreEl.innerText = this.score;
        this.saveScore();
        this.updateLeaderboard();
        this.gameOverScreen.classList.remove('hidden');
    }

    saveScore() {
        let scores = JSON.parse(localStorage.getItem('flappyScores')) || [];
        scores.push({ name: this.username, score: this.score, theme: this.currentTheme });
        scores.sort((a, b) => b.score - a.score);
        scores = scores.slice(0, 5); // Keep top 5
        localStorage.setItem('flappyScores', JSON.stringify(scores));
    }

    updateLeaderboard() {
        const table = document.getElementById('leaderboard-table');
        table.innerHTML = '';
        const scores = JSON.parse(localStorage.getItem('flappyScores')) || [];
        
        scores.forEach(s => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${s.name}</td><td>${s.score}</td>`;
            table.appendChild(row);
        });
    }
}

// Start Game Loop
const game = new Game('gameCanvas');

</script>
</body>
</html>