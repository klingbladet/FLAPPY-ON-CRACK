<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy All-Stars & Themes</title>
    <!-- Google Fonts for retro feel -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            height: 100%;
            max-height: 800px;
            background-color: #70c5ce;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        #score-display {
            position: absolute;
            top: 10%;
            font-size: 3rem;
            color: white;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }

        #lives-display {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5rem;
            color: #ff4444;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
            text-align: left;
        }

        #start-screen, #game-over-screen {
            background: rgba(0, 0, 0, 0.9);
            padding: 1.5rem;
            border-radius: 10px;
            pointer-events: auto;
            color: white;
            border: 2px solid white;
            width: 90%;
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        h1 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #f4ce42;
            text-shadow: 3px 3px 0 #000;
        }

        p {
            font-size: 0.7rem;
            margin-bottom: 0.5rem;
            line-height: 1.5;
            color: #aaa;
        }

        input[type="text"] {
            background: #333;
            border: 2px solid #fff;
            color: #fff;
            padding: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            width: 100%;
            text-align: center;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .btn {
            background: #e06018;
            border: 2px solid white;
            color: white;
            padding: 12px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 4px 4px 0 #000;
            transition: transform 0.1s;
            margin-top: 10px;
            width: 100%;
        }

        .btn-secondary {
            background: #444;
            margin-top: 10px;
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 2px 2px 0 #000;
        }

        .selector-label {
            margin-top: 10px;
            color: #fff;
            text-transform: uppercase;
            font-size: 0.7rem;
            text-align: left;
        }

        .option-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-bottom: 10px;
        }

        .opt-btn {
            padding: 8px 2px;
            font-size: 0.5rem;
            background: #444;
            border: 2px solid #777;
            color: #ccc;
            cursor: pointer;
            box-shadow: 2px 2px 0 #000;
        }

        .opt-btn.selected {
            background: #73bf2e;
            border-color: #fff;
            color: #fff;
            transform: scale(1.05);
        }
        
        /* Character Highlights */
        .opt-btn[data-char="cartman"].selected { background: #E74C3C; }
        .opt-btn[data-char="naruto"].selected { background: #F39C12; }
        .opt-btn[data-char="killua"].selected { background: #95A5A6; }
        .opt-btn[data-char="stalin"].selected { background: #6E2C00; }
        .opt-btn[data-char="mussolini"].selected { background: #212F3C; }
        .opt-btn[data-char="kim"].selected { background: #333; }

        /* Theme Highlights */
        .opt-btn[data-theme="soviet"].selected { background: #C0392B; }
        .opt-btn[data-theme="leaf"].selected { background: #58D68D; color: #000; }
        .opt-btn[data-theme="southpark"].selected { background: #AED6F1; color: #000; }

        .leaderboard-container {
            margin-top: 15px;
            width: 100%;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        
        table {
            width: 100%;
            font-size: 0.6rem;
            color: #ccc;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 5px;
            text-align: left;
            border-bottom: 1px solid #444;
        }
        
        td:last-child {
            text-align: right;
            color: #f4ce42;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="score-display">0</div>
    <div id="lives-display">‚ù§Ô∏è‚ù§Ô∏è</div>

    <div id="ui-layer">
        <!-- START SCREEN -->
        <div id="start-screen">
            <h1>FLAPPY ALL-STARS</h1>
            
            <input type="text" id="username-input" placeholder="ENTER NAME" maxlength="8">

            <p class="selector-label">Theme</p>
            <div class="option-grid" id="theme-selector">
                <button class="opt-btn" data-theme="soviet">SOVIET</button>
                <button class="opt-btn selected" data-theme="leaf">LEAF</button>
                <button class="opt-btn" data-theme="southpark">S. PARK</button>
            </div>

            <p class="selector-label">Character</p>
            <div class="option-grid" id="char-selector">
                <button class="opt-btn selected" data-char="cartman">CARTMAN</button>
                <button class="opt-btn" data-char="naruto">NARUTO</button>
                <button class="opt-btn" data-char="killua">KILLUA</button>
                <button class="opt-btn" data-char="stalin">STALIN</button>
                <button class="opt-btn" data-char="mussolini">MUSSOLINI</button>
                <button class="opt-btn" data-char="kim">KIM</button>
            </div>

            <p class="selector-label">Difficulty</p>
            <div class="option-grid" id="diff-selector">
                <button class="opt-btn" data-diff="easy">EASY</button>
                <button class="opt-btn selected" data-diff="normal">NORMAL</button>
                <button class="opt-btn" data-diff="hard">HARD</button>
            </div>

            <button id="start-btn" class="btn">START GAME</button>
            <p style="margin-top:10px; font-size: 0.5rem; color: #ff6666;">*Right-click to shoot in Normal/Hard*</p>
        </div>

        <!-- GAME OVER SCREEN -->
        <div id="game-over-screen" class="hidden">
            <h1>GAME OVER</h1>
            <p>Score: <span id="final-score">0</span></p>
            
            <div class="leaderboard-container">
                <p>LEADERBOARD</p>
                <table id="leaderboard-table">
                    <!-- Populated by JS -->
                </table>
            </div>

            <button id="restart-btn" class="btn">TRY AGAIN</button>
            <button id="menu-btn" class="btn btn-secondary">CHANGE SETTINGS</button>
        </div>
    </div>
</div>

<script>

/**
 * Game Configuration
 */
const DIFFICULTIES = {
    easy: { 
        speed: 2, // Made slightly faster
        pipeInterval: 2200, 
        gap: 190, // Slightly tighter gap
        enemyChance: 0 
    },
    normal: { 
        speed: 3, 
        pipeInterval: 1700, 
        gap: 170, 
        enemyChance: 0.003 // Small chance for enemies
    },
    hard: { 
        speed: 4, 
        pipeInterval: 1400, 
        gap: 150, 
        enemyChance: 0.008 // Frequent enemies
    }
};

const THEMES = {
    soviet: {
        bgSky: '#5D6D7E', 
        bgGround: '#2C3E50', 
        pipeMain: '#5D6D7E',
        pipeStroke: '#17202A',
        clouds: false,
        factories: true,
        mountains: false,
        lifeIcon: '‚≠ê'
    },
    leaf: {
        bgSky: '#85C1E9', 
        bgGround: '#58D68D', 
        pipeMain: '#A04000', // Wood
        pipeStroke: '#6E2C00',
        clouds: true,
        factories: false,
        mountains: false,
        lifeIcon: 'üçú'
    },
    southpark: {
        bgSky: '#AED6F1', 
        bgGround: '#FBFCFC', // Snow
        pipeMain: '#2ECC71',
        pipeStroke: '#27AE60',
        clouds: true,
        factories: false,
        mountains: true,
        lifeIcon: 'üßÄ'
    }
};

const CHARACTERS = {
    cartman: { color: '#E74C3C', hat: '#3498DB', face: '#F5CBA7' },
    naruto: { color: '#F39C12', hair: '#F1C40F', face: '#F5CBA7' },
    killua: { color: '#34495E', hair: '#ECF0F1', face: '#FDFEFE' },
    stalin: { color: '#6E2C00', uniform: '#D4AC0D', face: '#F5CBA7' },
    mussolini: { color: '#212F3C', uniform: '#212F3C', face: '#F5CBA7' },
    kim: { color: '#2C3E50', suit: '#2C3E50', face: '#F5CBA7' }
};

/**
 * Base Entity
 */
class Entity {
    constructor(x, y, width, height, color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.color = color;
        this.markedForDeletion = false;
    }
    update() {}
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    collidesWith(other) {
        const padding = 4;
        return (
            this.x + padding < other.x + other.width - padding &&
            this.x + this.width - padding > other.x + padding &&
            this.y + padding < other.y + other.height - padding &&
            this.y + this.height - padding > other.y + padding
        );
    }
}

/**
 * Projectile Class
 */
class Projectile extends Entity {
    constructor(x, y, targetX, targetY, theme) {
        super(x, y, 15, 15, '#fff');
        this.theme = theme;
        this.speed = 8;
        
        // Calculate velocity vector
        const dx = targetX - x;
        const dy = targetY - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        this.vx = (dx / dist) * this.speed;
        this.vy = (dy / dist) * this.speed;
        
        this.rotation = 0;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += 0.2;
        
        // Remove if off screen
        if (this.x < 0 || this.x > 2000 || this.y < 0 || this.y > 2000) {
            this.markedForDeletion = true;
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        if (this.theme === 'soviet') {
            // Sickle
            ctx.strokeStyle = '#C0392B';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0.5, Math.PI * 1.5);
            ctx.stroke();
            ctx.fillStyle = '#C0392B';
            ctx.fillRect(-2, 0, 4, 10);
        } else if (this.theme === 'leaf') {
            // Kunai / Shuriken
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.moveTo(0, -8); ctx.lineTo(6, 0);
            ctx.lineTo(0, 8); ctx.lineTo(-6, 0);
            ctx.fill();
        } else {
            // Snowball
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
}

/**
 * Enemy Class
 */
class Enemy extends Entity {
    constructor(x, y, theme) {
        super(x, y, 40, 40, '#000');
        this.theme = theme;
        this.vx = Math.random() * 2 + 1; // Speed
        this.wobble = Math.random() * Math.PI * 2;
    }

    update() {
        this.x -= this.vx;
        this.wobble += 0.1;
        this.y += Math.sin(this.wobble) * 2;
        
        if (this.x + this.width < 0) this.markedForDeletion = true;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + 20, this.y + 20);
        
        if (this.theme === 'soviet') {
            // The Capitalist
            ctx.fillStyle = '#000'; // Suit
            ctx.fillRect(-15, 0, 30, 20);
            ctx.fillStyle = '#F5CBA7'; // Face
            ctx.beginPath(); ctx.arc(0, -5, 15, 0, Math.PI*2); ctx.fill();
            // Top Hat
            ctx.fillStyle = '#17202A';
            ctx.fillRect(-15, -25, 30, 15);
            ctx.fillRect(-20, -10, 40, 5);
            // Monocle
            ctx.strokeStyle = '#F1C40F';
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(5, -5, 5, 0, Math.PI*2); ctx.stroke();
            
        } else if (this.theme === 'leaf') {
            // Rogue Ninja
            ctx.fillStyle = '#212F3C'; // Dark cloak
            ctx.beginPath(); ctx.arc(0, 0, 18, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#F5CBA7'; // Face
            ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
            // Mask
            ctx.fillStyle = '#17202A';
            ctx.fillRect(-10, 2, 20, 10);
            // Scratch on headband
            ctx.fillStyle = '#7F8C8D'; ctx.fillRect(-12, -12, 24, 6);
            ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.moveTo(-5, -12); ctx.lineTo(5, -6); ctx.stroke();

        } else {
            // Professor Chaos (South Park)
            ctx.fillStyle = '#D7DBDD'; // Foil
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#F5CBA7'; // Face hole
            ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(-4, 0, 2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(4, 0, 2, 0, Math.PI*2); ctx.fill();
        }
        ctx.restore();
    }
}

/**
 * PowerUp Class
 */
class PowerUp extends Entity {
    constructor(x, y, type, theme) {
        super(x, y, 35, 35, type === 'life' ? 'red' : 'gold');
        this.type = type; 
        this.theme = theme;
        this.initialY = y;
        this.angle = 0;
    }

    update(speed) {
        this.x -= speed;
        this.angle += 0.1;
        this.y = this.initialY + Math.sin(this.angle) * 20;
        if (this.x + this.width < 0) this.markedForDeletion = true;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        
        if (this.theme === 'soviet') {
            if (this.type === 'life') {
                this.drawStar(ctx, 0, 0, 5, 15, 7, '#E74C3C', '#C0392B');
            } else {
                ctx.rotate(Math.sin(this.angle));
                ctx.fillStyle = '#F1C40F';
                ctx.fillRect(-4, -10, 8, 20); ctx.fillRect(-10, -12, 20, 8);
            }
        } else if (this.theme === 'leaf') {
            if (this.type === 'life') {
                ctx.fillStyle = '#E59866'; ctx.beginPath(); ctx.arc(0, 5, 15, 0, Math.PI); ctx.fill();
                ctx.fillStyle = '#F7DC6F'; ctx.beginPath(); ctx.ellipse(0, 5, 14, 4, 0, 0, Math.PI*2); ctx.fill();
            } else {
                ctx.rotate(this.angle * 2);
                ctx.fillStyle = '#5D6D7E';
                ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(4, -4); ctx.lineTo(15, 0); ctx.lineTo(4, 4);
                ctx.lineTo(0, 15); ctx.lineTo(-4, 4); ctx.lineTo(-15, 0); ctx.lineTo(-4, -4); ctx.fill();
            }
        } else if (this.theme === 'southpark') {
            if (this.type === 'life') {
                ctx.fillStyle = '#FF7F50'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#C0392B'; for(let i=0; i<5; i++) { ctx.beginPath(); ctx.arc(Math.random()*20-10, Math.random()*20-10, 2, 0, Math.PI*2); ctx.fill(); }
            } else {
                ctx.rotate(this.angle); ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
                for(let i=0; i<3; i++) { ctx.beginPath(); ctx.moveTo(0, -15); ctx.lineTo(0, 15); ctx.stroke(); ctx.rotate(Math.PI/3); }
            }
        }
        ctx.restore();
    }

    drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius, fill, stroke) {
        let rot = Math.PI / 2 * 3;
        let x = cx, y = cy, step = Math.PI / spikes;
        ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step;
            x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius); ctx.closePath();
        ctx.lineWidth = 2; ctx.strokeStyle = stroke; ctx.stroke(); ctx.fillStyle = fill; ctx.fill();
    }
}

/**
 * Character Class
 */
class Character extends Entity {
    constructor(gameHeight, type = 'cartman') {
        super(50, gameHeight / 2, 40, 40, CHARACTERS[type].color);
        this.type = type;
        this.velocity = 0;
        this.gravity = 0.5; 
        this.jumpStrength = -8; 
        this.rotation = 0;
        this.gameHeight = gameHeight;
        this.invincible = false;
        this.invincibleTimer = 0;
        this.hue = 0;
    }

    flap() {
        this.velocity = this.jumpStrength;
    }

    activateStar() {
        this.invincible = true;
        this.invincibleTimer = 300; 
    }

    update() {
        this.velocity += this.gravity;
        this.y += this.velocity;

        if (this.velocity < 0) {
            this.rotation = -25 * (Math.PI / 180);
        } else {
            this.rotation += 2 * (Math.PI / 180);
            if(this.rotation > 90 * (Math.PI / 180)) this.rotation = 90 * (Math.PI / 180);
        }

        if (this.invincible) {
            this.invincibleTimer--;
            this.hue += 10;
            if (this.invincibleTimer <= 0) {
                this.invincible = false;
            }
        }

        if (this.y + this.height > this.gameHeight - 50) {
            this.y = this.gameHeight - 50 - this.height;
            return 'ground';
        }
        if (this.y < 0) {
            this.y = 0;
            this.velocity = 0;
        }
        return false;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
        ctx.rotate(this.rotation);

        let config = CHARACTERS[this.type];
        
        if (this.invincible) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = `hsl(${this.hue}, 100%, 50%)`;
        }

        this.drawSpecificCharacter(ctx, config);
        ctx.restore();
    }

    drawSpecificCharacter(ctx, config) {
        ctx.fillStyle = config.face;
        
        if (this.type === 'cartman') {
            ctx.fillStyle = config.color; 
            ctx.beginPath(); ctx.arc(0, 10, 22, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = config.face;
            ctx.beginPath(); ctx.arc(0, -5, 18, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(0, 5, 10, 0, Math.PI); ctx.stroke();
            ctx.fillStyle = config.hat; 
            ctx.beginPath(); ctx.arc(0, -10, 19, Math.PI, 0); ctx.fill();
            ctx.fillStyle = '#F1C40F';
            ctx.beginPath(); ctx.ellipse(0, -28, 5, 3, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.moveTo(-18, -10); ctx.lineTo(18, -10); ctx.stroke();
        } else if (this.type === 'naruto') {
            ctx.fillStyle = config.color; 
            ctx.fillRect(-15, 10, 30, 20);
            ctx.fillStyle = config.face;
            ctx.beginPath(); ctx.arc(0, -5, 16, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = config.hair;
            ctx.beginPath();
            for(let i=0; i<7; i++) { ctx.lineTo(-20 + (i*6), -30 + (Math.random()*10)); ctx.lineTo(-17 + (i*6), -15); }
            ctx.fill();
            ctx.fillStyle = '#2C3E50'; ctx.fillRect(-16, -18, 32, 6);
            ctx.fillStyle = '#95A5A6'; ctx.fillRect(-8, -17, 16, 4);
            ctx.strokeStyle = '#000'; ctx.beginPath();
            ctx.moveTo(-12, -2); ctx.lineTo(-6, -1); ctx.moveTo(-12, 1); ctx.lineTo(-6, 2); ctx.moveTo(-12, 4); ctx.lineTo(-6, 5);
            ctx.moveTo(12, -2); ctx.lineTo(6, -1); ctx.moveTo(12, 1); ctx.lineTo(6, 2); ctx.moveTo(12, 4); ctx.lineTo(6, 5);
            ctx.stroke();
        } else if (this.type === 'killua') {
            ctx.fillStyle = config.color; ctx.fillRect(-15, 10, 30, 20);
            ctx.fillStyle = config.face; ctx.beginPath(); ctx.arc(0, -5, 15, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = config.hair; ctx.beginPath();
            ctx.moveTo(-20, -10); ctx.lineTo(-25, -25); ctx.lineTo(-10, -15); ctx.lineTo(0, -30);
            ctx.lineTo(10, -15); ctx.lineTo(25, -25); ctx.lineTo(20, -10); ctx.fill();
            ctx.fillStyle = '#2E86C1'; ctx.beginPath();
            ctx.ellipse(-6, -2, 4, 2, 0.2, 0, Math.PI*2); ctx.ellipse(6, -2, 4, 2, -0.2, 0, Math.PI*2); ctx.fill();
        } else if (this.type === 'stalin') {
            ctx.fillStyle = config.color; ctx.fillRect(-18, 8, 36, 22);
            ctx.fillStyle = config.face; ctx.fillRect(-15, -20, 30, 30);
            ctx.fillStyle = '#212121'; ctx.beginPath();
            ctx.moveTo(-15, -15); ctx.quadraticCurveTo(0, -25, 15, -15); ctx.lineTo(15, -22); ctx.quadraticCurveTo(0, -32, -15, -22); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath();
            ctx.moveTo(-10, 5); ctx.quadraticCurveTo(0, 0, 10, 5); ctx.quadraticCurveTo(12, 8, 8, 8); ctx.quadraticCurveTo(0, 5, -8, 8); ctx.quadraticCurveTo(-12, 8, -10, 5); ctx.fill();
        } else if (this.type === 'mussolini') {
            ctx.fillStyle = config.color; ctx.fillRect(-18, 8, 36, 22);
            ctx.fillStyle = config.face; ctx.beginPath(); ctx.ellipse(0, -8, 16, 18, 0, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#D68910'; ctx.beginPath(); ctx.arc(0, 8, 5, 0, Math.PI); ctx.stroke();
        } else if (this.type === 'kim') {
            ctx.fillStyle = config.suit; ctx.fillRect(-18, 8, 36, 22);
            ctx.fillStyle = config.face; ctx.beginPath(); ctx.arc(0, -5, 18, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.fillRect(-18, -25, 36, 10);
            ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.beginPath();
            ctx.moveTo(-12, -5); ctx.lineTo(-2, -5); ctx.moveTo(2, -5); ctx.lineTo(12, -5); ctx.stroke();
        }

        if (this.type !== 'killua') {
            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-6, -5, 4, 0, Math.PI*2); ctx.arc(6, -5, 4, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-5, -5, 2, 0, Math.PI*2); ctx.arc(7, -5, 2, 0, Math.PI*2); ctx.fill();
        }
    }
}

class Pipe extends Entity {
    constructor(x, y, width, height, type, theme) {
        super(x, y, width, height, '#73bf2e');
        this.type = type;
        this.theme = theme;
        this.passed = false;
        this.mainColor = THEMES[theme].pipeMain;
        this.strokeColor = THEMES[theme].pipeStroke;
    }

    update(speed) {
        this.x -= speed;
        if (this.x + this.width < 0) this.markedForDeletion = true;
    }

    draw(ctx) {
        ctx.fillStyle = this.mainColor;
        ctx.strokeStyle = this.strokeColor;
        ctx.lineWidth = 2;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.strokeRect(this.x, this.y, this.width, this.height);

        const capHeight = 20;
        const capExtension = 4;
        let capY = this.type === 'top' ? this.y + this.height - capHeight : this.y;
        ctx.fillRect(this.x - capExtension, capY, this.width + (capExtension*2), capHeight);
        ctx.strokeRect(this.x - capExtension, capY, this.width + (capExtension*2), capHeight);
        
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = '#000';
        if(this.theme === 'leaf') {
             ctx.beginPath(); ctx.arc(this.x+30, this.y+30, 10, 0, Math.PI*2); ctx.fill();
        } else if (this.theme === 'soviet') {
             ctx.fillRect(this.x+5, capY+5, 4, 4);
             ctx.fillRect(this.x+this.width-9, capY+5, 4, 4);
        }
        ctx.globalAlpha = 1.0;
    }
}

class Background {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this.cloudOffset = 0;
        this.groundOffset = 0;
        this.decorations = []; // For floating weapons
    }

    update(speed) {
        this.cloudOffset -= speed * 0.2;
        if (this.cloudOffset <= -this.width) this.cloudOffset = 0;
        this.groundOffset -= speed;
        if (this.groundOffset <= -20) this.groundOffset = 0;
    }

    draw(ctx, themeName) {
        const theme = THEMES[themeName];
        ctx.fillStyle = theme.bgSky;
        ctx.fillRect(0, 0, this.width, this.height);

        // Draw Floating Decorations (Weapons)
        this.drawDecorations(ctx, themeName);

        if (theme.clouds) {
             ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
             for(let i=0; i<5; i++) {
                let xPos = (i * 200 + this.cloudOffset) % (this.width + 200);
                if(xPos < -100) xPos += this.width + 200;
                this.drawCloud(ctx, xPos, 100 + (i%2)*50);
             }
        }
        
        if (theme.mountains) {
             ctx.fillStyle = '#ECF0F1';
             for(let i=0; i<5; i++) {
                 let x = (i * 150 + this.cloudOffset * 0.5) % (this.width + 300);
                 if(x < -150) x += this.width + 300;
                 ctx.beginPath(); ctx.moveTo(x, this.height-50); ctx.lineTo(x+100, this.height-250); ctx.lineTo(x+200, this.height-50); ctx.fill();
             }
        }

        if (theme.factories) {
            ctx.fillStyle = '#2C3E50';
             for(let i=0; i<6; i++) {
                let x = (i * 120 + this.cloudOffset * 0.5) % (this.width + 120);
                if(x < -100) x += this.width + 120;
                ctx.fillRect(x, this.height - 150 - (i%2)*30, 60, 200);
                ctx.fillStyle = '#F4D03F'; ctx.fillRect(x+10, this.height - 120, 10, 10); ctx.fillStyle = '#2C3E50';
             }
        }

        ctx.fillStyle = theme.bgGround; ctx.fillRect(0, this.height - 50, this.width, 50);
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(0, this.height - 50, this.width, 5);
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        for(let i=0; i < this.width + 20; i+=20) {
            ctx.beginPath();
            ctx.moveTo(i + this.groundOffset, this.height - 50); ctx.lineTo(i + this.groundOffset - 15, this.height);
            ctx.lineTo(i + this.groundOffset - 10, this.height); ctx.lineTo(i + this.groundOffset + 5, this.height - 50);
            ctx.fill();
        }
    }

    drawDecorations(ctx, theme) {
        // Draw some static decorations that move with parallax
        ctx.save();
        ctx.globalAlpha = 0.4; // Faint in background
        for(let i=0; i<6; i++) {
            let x = (i * 250 + this.cloudOffset * 0.8) % (this.width + 250);
            if(x < -100) x += this.width + 250;
            let y = 100 + (i * 50) % 300;
            
            ctx.translate(x, y);
            ctx.rotate(this.cloudOffset * 0.01 + i); // Rotate slowly
            
            if (theme === 'soviet') {
                // Background Sickle
                ctx.strokeStyle = '#922B21'; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.arc(0, 0, 20, 0.5, Math.PI * 1.5); ctx.stroke();
                ctx.fillStyle = '#922B21'; ctx.fillRect(-5, 0, 8, 20);
            } else if (theme === 'leaf') {
                // Background Kunai
                ctx.fillStyle = '#34495E';
                ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(8, 0); ctx.lineTo(0, 20); ctx.lineTo(-8, 0); ctx.fill();
            } else if (theme === 'southpark') {
                // Background Snowflake
                ctx.strokeStyle = '#D6EAF8'; ctx.lineWidth = 4;
                for(let j=0; j<3; j++) { ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(0, 20); ctx.stroke(); ctx.rotate(Math.PI/3); }
            }
            ctx.rotate(-(this.cloudOffset * 0.01 + i)); // Reset rotation
            ctx.translate(-x, -y);
        }
        ctx.restore();
    }

    drawCloud(ctx, x, y) {
        ctx.beginPath();
        ctx.arc(x, y, 30, 0, Math.PI * 2);
        ctx.arc(x + 25, y - 10, 35, 0, Math.PI * 2);
        ctx.arc(x + 50, y, 30, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Particle extends Entity {
    constructor(x, y, color = null) {
        const c = color || `hsl(${Math.random()*360}, 100%, 50%)`;
        super(x, y, Math.random() * 5 + 2, Math.random() * 5 + 2, c);
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.life = 1.0;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.life -= 0.02;
        if(this.life <= 0) this.markedForDeletion = true;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life; super.draw(ctx); ctx.globalAlpha = 1.0;
    }
}

/**
 * GAME CONTROLLER
 */
class Game {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        this.currentDifficulty = 'normal';
        this.currentCharacter = 'cartman';
        this.currentTheme = 'leaf';
        this.username = "PLAYER";
        
        this.lastTime = 0;
        this.score = 0;
        this.lives = 1;
        this.isRunning = false;
        this.isGameOver = false;
        
        this.bird = null;
        this.background = new Background(this.canvas.width, this.canvas.height);
        this.pipes = [];
        this.particles = [];
        this.powerups = [];
        this.enemies = []; // Store enemies
        this.projectiles = []; // Store aimed shots
        this.hurtTimer = 0;
        
        // Track mouse position for keyboard shooting
        this.mousePos = { x: 0, y: 0 };

        this.speed = 3;

        this.scoreEl = document.getElementById('score-display');
        this.livesEl = document.getElementById('lives-display');
        this.finalScoreEl = document.getElementById('final-score');
        this.startScreen = document.getElementById('start-screen');
        this.gameOverScreen = document.getElementById('game-over-screen');
        this.usernameInput = document.getElementById('username-input');

        this.setupInputs();
        this.setupUI();
        this.background.draw(this.ctx, this.currentTheme);
    }

    resize() {
        const container = this.canvas.parentElement;
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        if (this.background) {
            this.background.width = this.canvas.width;
            this.background.height = this.canvas.height;
        }
    }

    setupUI() {
        this.setupBtnGroup('#diff-selector .opt-btn', (val) => this.currentDifficulty = val);
        this.setupBtnGroup('#char-selector .opt-btn', (val) => this.currentCharacter = val);
        this.setupBtnGroup('#theme-selector .opt-btn', (val) => {
            this.currentTheme = val;
            this.background.draw(this.ctx, this.currentTheme);
        });
    }

    setupBtnGroup(selector, callback) {
        const btns = document.querySelectorAll(selector);
        btns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                btns.forEach(b => b.classList.remove('selected'));
                e.target.classList.add('selected');
                callback(e.target.dataset.diff || e.target.dataset.char || e.target.dataset.theme);
            });
        });
    }

    setupInputs() {
        // Track mouse position globally
        window.addEventListener('mousemove', (e) => {
            this.mousePos = { x: e.clientX, y: e.clientY };
        });

        const action = (e) => {
            if (e.type !== 'touchstart' && (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT')) return;
            if (e.type === 'touchstart' && e.target.tagName !== 'BUTTON') e.preventDefault();

            if (this.isRunning && !this.isGameOver) {
                // Left click or tap handles jumping
                if(e.button !== 2) this.bird.flap();
            }
        };

        // Shared shooting logic
        const performShoot = (clientX, clientY) => {
            const difficulty = DIFFICULTIES[this.currentDifficulty];
            // Allow shooting in Normal and Hard modes
            if (this.isRunning && !this.isGameOver && difficulty.enemyChance > 0) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                const aimX = (clientX - rect.left) * scaleX;
                const aimY = (clientY - rect.top) * scaleY;
                
                // Shoot projectile from bird to mouse location
                this.projectiles.push(new Projectile(this.bird.x + this.bird.width/2, this.bird.y + this.bird.height/2, aimX, aimY, this.currentTheme));
            }
        };

        // Right-click aiming handler
        this.canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Stop context menu
            performShoot(e.clientX, e.clientY);
        });

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if(document.activeElement !== this.usernameInput) {
                    e.preventDefault(); 
                    action({type: 'keydown'});
                }
            }
            // Shoot with Shift keys using current mouse position
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                if(document.activeElement !== this.usernameInput) {
                    performShoot(this.mousePos.x, this.mousePos.y);
                }
            }
        });
        
        this.canvas.addEventListener('mousedown', action);
        this.canvas.addEventListener('touchstart', action, { passive: false });

        document.getElementById('start-btn').addEventListener('click', () => this.start());
        document.getElementById('restart-btn').addEventListener('click', () => this.start());
        document.getElementById('menu-btn').addEventListener('click', () => {
             this.gameOverScreen.classList.add('hidden');
             this.startScreen.classList.remove('hidden');
        });
    }

    spawnPipe() {
        const settings = DIFFICULTIES[this.currentDifficulty];
        const pipeWidth = 60;
        const gap = settings.gap;
        const minPipeHeight = 50;
        const maxPipeHeight = this.canvas.height - gap - minPipeHeight - 100;

        const topHeight = Math.floor(Math.random() * (maxPipeHeight - minPipeHeight + 1) + minPipeHeight);
        
        this.pipes.push(new Pipe(this.canvas.width, 0, pipeWidth, topHeight, 'top', this.currentTheme));
        const bottomY = topHeight + gap;
        this.pipes.push(new Pipe(this.canvas.width, bottomY, pipeWidth, this.canvas.height - bottomY - 50, 'bottom', this.currentTheme));

        if (Math.random() < 0.3) { 
            const type = Math.random() > 0.7 ? 'star' : 'life'; 
            const pY = topHeight + (gap/2) - 15;
            this.powerups.push(new PowerUp(this.canvas.width + 30, pY, type, this.currentTheme));
        }
    }

    updateLivesDisplay() {
        const icon = THEMES[this.currentTheme].lifeIcon;
        let text = '';
        for(let i=0; i<this.lives; i++) text += icon;
        this.livesEl.innerText = text;
    }

    saveScore() {
        const scoreEntry = {
            name: this.username || "ANONYMOUS",
            score: this.score,
            date: new Date().toISOString()
        };

        let leaderboard = JSON.parse(localStorage.getItem('flappy_leaderboard') || '[]');
        leaderboard.push(scoreEntry);
        leaderboard.sort((a, b) => b.score - a.score);
        leaderboard = leaderboard.slice(0, 5);
        localStorage.setItem('flappy_leaderboard', JSON.stringify(leaderboard));
        this.renderLeaderboard(leaderboard);
    }

    renderLeaderboard(leaderboard) {
        const table = document.getElementById('leaderboard-table');
        table.innerHTML = ''; 
        leaderboard.forEach((entry, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `<td>${index + 1}.</td><td>${entry.name}</td><td>${entry.score}</td>`;
            table.appendChild(row);
        });
    }

    start() {
        const inputName = this.usernameInput.value.trim();
        if(inputName.length > 0) this.username = inputName;

        const settings = DIFFICULTIES[this.currentDifficulty];
        this.speed = settings.speed;
        
        this.bird = new Character(this.canvas.height, this.currentCharacter);
        this.pipes = [];
        this.particles = [];
        this.powerups = [];
        this.enemies = [];
        this.projectiles = [];
        this.score = 0;
        this.lives = 1;
        this.hurtTimer = 0;

        this.isRunning = true;
        this.isGameOver = false;
        this.pipeTimer = 0;
        this.pipeInterval = settings.pipeInterval;

        this.scoreEl.innerText = this.score;
        this.scoreEl.classList.remove('hidden');
        this.livesEl.classList.remove('hidden');
        this.updateLivesDisplay();
        
        this.startScreen.classList.add('hidden');
        this.gameOverScreen.classList.add('hidden');

        this.lastTime = performance.now();
        requestAnimationFrame((ts) => this.loop(ts));
    }

    takeDamage() {
        if (this.bird.invincible || this.hurtTimer > 0) return;

        this.lives--;
        this.updateLivesDisplay();

        if (this.lives > 0) {
            this.hurtTimer = 100; 
        } else {
            this.stop();
        }
    }

    stop() {
        this.isRunning = false;
        this.isGameOver = true;
        this.saveScore(); 

        this.finalScoreEl.innerText = this.score;
        this.scoreEl.classList.add('hidden');
        this.livesEl.classList.add('hidden');
        this.gameOverScreen.classList.remove('hidden');
        this.draw();
    }

    createExplosion(x, y, color) {
        for(let i=0; i<20; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    loop(timestamp) {
        if (!this.isRunning) {
            if(this.particles.length > 0) {
                this.updateParticles();
                this.draw();
                requestAnimationFrame((ts) => this.loop(ts));
            }
            return;
        }

        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;

        this.update(deltaTime);
        this.draw();

        requestAnimationFrame((ts) => this.loop(ts));
    }

    update(deltaTime) {
        this.background.update(this.speed);

        const status = this.bird.update();
        if (status === 'ground') {
            this.lives = 0; 
            this.stop();
        }

        if (this.hurtTimer > 0) this.hurtTimer--;

        this.pipeTimer += deltaTime;
        if (this.pipeTimer > this.pipeInterval) {
            this.spawnPipe();
            this.pipeTimer = 0;
        }

        // --- ENEMY SPAWNING (Normal and Hard Mode) ---
        const difficulty = DIFFICULTIES[this.currentDifficulty];
        if (difficulty.enemyChance > 0 && Math.random() < difficulty.enemyChance) {
            // Spawn Enemy at right edge at random height
            const yPos = Math.random() * (this.canvas.height - 200) + 50;
            this.enemies.push(new Enemy(this.canvas.width, yPos, this.currentTheme));
        }

        this.enemies.forEach(enemy => {
            enemy.update();
            if (this.bird.collidesWith(enemy)) {
                this.takeDamage();
                enemy.markedForDeletion = true; // Destroy enemy on impact
            }
        });

        this.projectiles.forEach(proj => {
            proj.update();
            // Check collision with enemies
            this.enemies.forEach(enemy => {
                if (proj.collidesWith(enemy)) {
                    enemy.markedForDeletion = true;
                    proj.markedForDeletion = true;
                    this.createExplosion(enemy.x, enemy.y, '#fff'); // Explosion
                }
            });
        });

        this.pipes.forEach(pipe => {
            pipe.update(this.speed);
            if (this.bird.collidesWith(pipe)) {
                this.takeDamage();
            }
            if (pipe.type === 'top' && !pipe.passed && pipe.x + pipe.width < this.bird.x) {
                this.score++;
                this.scoreEl.innerText = this.score;
                pipe.passed = true;
                if(this.score % 5 === 0 && this.speed < 8) this.speed += 0.2;
            }
        });

        this.powerups.forEach(p => {
            p.update(this.speed);
            if(this.bird.collidesWith(p)) {
                p.markedForDeletion = true;
                if(p.type === 'life') {
                    if (this.lives < 2) this.lives++; 
                    this.updateLivesDisplay();
                } else if (p.type === 'star') {
                    this.bird.activateStar();
                }
            }
        });

        this.pipes = this.pipes.filter(p => !p.markedForDeletion);
        this.powerups = this.powerups.filter(p => !p.markedForDeletion);
        this.enemies = this.enemies.filter(e => !e.markedForDeletion);
        this.projectiles = this.projectiles.filter(p => !p.markedForDeletion);
    }

    updateParticles() {
        this.particles.forEach(p => p.update());
        this.particles = this.particles.filter(p => !p.markedForDeletion);
    }

    draw() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        this.background.draw(this.ctx, this.currentTheme);
        this.pipes.forEach(pipe => pipe.draw(this.ctx));
        this.powerups.forEach(p => p.draw(this.ctx));
        this.enemies.forEach(e => e.draw(this.ctx));
        this.projectiles.forEach(p => p.draw(this.ctx));
        
        if (this.bird) {
            if (this.hurtTimer > 0 && Math.floor(Date.now() / 50) % 2 === 0) {
            } else {
                this.bird.draw(this.ctx);
            }
        }

        this.particles.forEach(p => p.draw(this.ctx));
        
        if(this.bird && this.bird.invincible) {
            this.ctx.fillStyle = 'gold';
            this.ctx.fillRect(0, 0, (this.bird.invincibleTimer/300) * this.canvas.width, 5);
        }
    }
}

window.onload = () => {
    const game = new Game('gameCanvas');
};

</script>
</body>
</html>